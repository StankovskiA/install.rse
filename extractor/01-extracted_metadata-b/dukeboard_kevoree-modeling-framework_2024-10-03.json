{
    "somef_provenance": {
        "somef_version": "0.9.5",
        "somef_schema_version": "1.0.0",
        "date": "2024-10-03 21:01:00"
    },
    "code_repository": [
        {
            "result": {
                "value": "https://github.com/dukeboard/kevoree-modeling-framework",
                "type": "Url"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "owner": [
        {
            "result": {
                "value": "dukeboard",
                "type": "User"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "date_created": [
        {
            "result": {
                "value": "2012-03-04T15:14:05Z",
                "type": "Date"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "date_updated": [
        {
            "result": {
                "value": "2023-06-17T15:44:22Z",
                "type": "Date"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "license": [
        {
            "result": {
                "value": "https://api.github.com/licenses/lgpl-3.0",
                "type": "License",
                "name": "GNU Lesser General Public License v3.0",
                "url": "https://api.github.com/licenses/lgpl-3.0",
                "spdx_id": "LGPL-3.0"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        },
        {
            "result": {
                "value": "                   GNU LESSER GENERAL PUBLIC LICENSE\n                       Version 3, 29 June 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n\n  This version of the GNU Lesser General Public License incorporates\nthe terms and conditions of version 3 of the GNU General Public\nLicense, supplemented by the additional permissions listed below.\n\n  0. Additional Definitions.\n\n  As used herein, \"this License\" refers to version 3 of the GNU Lesser\nGeneral Public License, and the \"GNU GPL\" refers to version 3 of the GNU\nGeneral Public License.\n\n  \"The Library\" refers to a covered work governed by this License,\nother than an Application or a Combined Work as defined below.\n\n  An \"Application\" is any work that makes use of an interface provided\nby the Library, but which is not otherwise based on the Library.\nDefining a subclass of a class defined by the Library is deemed a mode\nof using an interface provided by the Library.\n\n  A \"Combined Work\" is a work produced by combining or linking an\nApplication with the Library.  The particular version of the Library\nwith which the Combined Work was made is also called the \"Linked\nVersion\".\n\n  The \"Minimal Corresponding Source\" for a Combined Work means the\nCorresponding Source for the Combined Work, excluding any source code\nfor portions of the Combined Work that, considered in isolation, are\nbased on the Application, and not on the Linked Version.\n\n  The \"Corresponding Application Code\" for a Combined Work means the\nobject code and/or source code for the Application, including any data\nand utility programs needed for reproducing the Combined Work from the\nApplication, but excluding the System Libraries of the Combined Work.\n\n  1. Exception to Section 3 of the GNU GPL.\n\n  You may convey a covered work under sections 3 and 4 of this License\nwithout being bound by section 3 of the GNU GPL.\n\n  2. Conveying Modified Versions.\n\n  If you modify a copy of the Library, and, in your modifications, a\nfacility refers to a function or data to be supplied by an Application\nthat uses the facility (other than as an argument passed when the\nfacility is invoked), then you may convey a copy of the modified\nversion:\n\n   a) under this License, provided that you make a good faith effort to\n   ensure that, in the event an Application does not supply the\n   function or data, the facility still operates, and performs\n   whatever part of its purpose remains meaningful, or\n\n   b) under the GNU GPL, with none of the additional permissions of\n   this License applicable to that copy.\n\n  3. Object Code Incorporating Material from Library Header Files.\n\n  The object code form of an Application may incorporate material from\na header file that is part of the Library.  You may convey such object\ncode under terms of your choice, provided that, if the incorporated\nmaterial is not limited to numerical parameters, data structure\nlayouts and accessors, or small macros, inline functions and templates\n(ten or fewer lines in length), you do both of the following:\n\n   a) Give prominent notice with each copy of the object code that the\n   Library is used in it and that the Library and its use are\n   covered by this License.\n\n   b) Accompany the object code with a copy of the GNU GPL and this license\n   document.\n\n  4. Combined Works.\n\n  You may convey a Combined Work under terms of your choice that,\ntaken together, effectively do not restrict modification of the\nportions of the Library contained in the Combined Work and reverse\nengineering for debugging such modifications, if you also do each of\nthe following:\n\n   a) Give prominent notice with each copy of the Combined Work that\n   the Library is used in it and that the Library and its use are\n   covered by this License.\n\n   b) Accompany the Combined Work with a copy of the GNU GPL and this license\n   document.\n\n   c) For a Combined Work that displays copyright notices during\n   execution, include the copyright notice for the Library among\n   these notices, as well as a reference directing the user to the\n   copies of the GNU GPL and this license document.\n\n   d) Do one of the following:\n\n       0) Convey the Minimal Corresponding Source under the terms of this\n       License, and the Corresponding Application Code in a form\n       suitable for, and under terms that permit, the user to\n       recombine or relink the Application with a modified version of\n       the Linked Version to produce a modified Combined Work, in the\n       manner specified by section 6 of the GNU GPL for conveying\n       Corresponding Source.\n\n       1) Use a suitable shared library mechanism for linking with the\n       Library.  A suitable mechanism is one that (a) uses at run time\n       a copy of the Library already present on the user's computer\n       system, and (b) will operate properly with a modified version\n       of the Library that is interface-compatible with the Linked\n       Version.\n\n   e) Provide Installation Information, but only if you would otherwise\n   be required to provide such information under section 6 of the\n   GNU GPL, and only to the extent that such information is\n   necessary to install and execute a modified version of the\n   Combined Work produced by recombining or relinking the\n   Application with a modified version of the Linked Version. (If\n   you use option 4d0, the Installation Information must accompany\n   the Minimal Corresponding Source and Corresponding Application\n   Code. If you use option 4d1, you must provide the Installation\n   Information in the manner specified by section 6 of the GNU GPL\n   for conveying Corresponding Source.)\n\n  5. Combined Libraries.\n\n  You may place library facilities that are a work based on the\nLibrary side by side in a single library together with other library\nfacilities that are not Applications and are not covered by this\nLicense, and convey such a combined library under terms of your\nchoice, if you do both of the following:\n\n   a) Accompany the combined library with a copy of the same work based\n   on the Library, uncombined with any other library facilities,\n   conveyed under the terms of this License.\n\n   b) Give prominent notice with the combined library that part of it\n   is a work based on the Library, and explaining where to find the\n   accompanying uncombined form of the same work.\n\n  6. Revised Versions of the GNU Lesser General Public License.\n\n  The Free Software Foundation may publish revised and/or new versions\nof the GNU Lesser General Public License from time to time. Such new\nversions will be similar in spirit to the present version, but may\ndiffer in detail to address new problems or concerns.\n\n  Each version is given a distinguishing version number. If the\nLibrary as you received it specifies that a certain numbered version\nof the GNU Lesser General Public License \"or any later version\"\napplies to it, you have the option of following the terms and\nconditions either of that published version or of any later version\npublished by the Free Software Foundation. If the Library as you\nreceived it does not specify a version number of the GNU Lesser\nGeneral Public License, you may choose any version of the GNU Lesser\nGeneral Public License ever published by the Free Software Foundation.\n\n  If the Library as you received it specifies that a proxy can decide\nwhether future versions of the GNU Lesser General Public License shall\napply, that proxy's public statement of acceptance of any version is\npermanent authorization for you to choose that version for the\nLibrary.",
                "type": "File_dump"
            },
            "confidence": 1,
            "technique": "file_exploration",
            "source": "https://raw.githubusercontent.com/dukeboard/kevoree-modeling-framework/master/LICENSE"
        }
    ],
    "description": [
        {
            "result": {
                "value": "Kevoree Modeling Framework",
                "type": "String"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        },
        {
            "result": {
                "value": "Each modification of a model now produces and propagates a ModelEvent. \nEvents are generated when:\n\n* Attributes are `set`\n* References are `set`, `added` or `removed` (the two last are only available for references with unbound max cardinality)\n* An opposite element is modified (only if the opposite relation is set).\n\nThe `source` of an event is the model element on which the modification applied, and is identified by its `path()`.\n",
                "type": "Text_excerpt",
                "original_header": "ModelEvent",
                "parent_header": [
                    "Model Events",
                    "API description"
                ]
            },
            "confidence": 1,
            "technique": "header_analysis",
            "source": "https://raw.githubusercontent.com/dukeboard/kevoree-modeling-framework/master/README.md"
        },
        {
            "result": {
                "value": "A ModeListener is an object that receives ModelEvents. Once registered on a model element, the method `elementChanged` of the ModelListener is called for each modification of the model element.\n\n```\ntrait ModelElementListener {\n    fun elementChanged(evt : ModelEvent)\n}\n```\n\nModel listeners can be registered on any model element. They can be registered as ModelElement listener or ModelTreeListener. The first one only receives events from the model element it registers on. The second receives any modification(reference or attribute modified) that occures on any sub-element in the containment hierarchy.\n\nOn the right, please find the extract of the KMFContainer API. Model listeners can be registered or unregistered using these methods on any model element. *removeModelTreeListener* method recursively unregisters a listener on child elements.\n\n```\ntrait KMFContainer {\n    fun addModelElementListener(lst : ModelElementListener)\n    fun removeModelElementListener(lst : ModelElementListener )\n    fun removeAllModelElementListeners()\n    fun addModelTreeListener(lst : ModelElementListener)\n    fun removeModelTreeListener(lst : ModelElementListener)\n    fun removeAllModelTreeListeners()\n}\n```\n\nFor instance, considering a very simple Finite State Machine metamodel <br /> \n(FSM<>--State<>--Transition<>--Action).\n\n``` java\nfsm.addModelTreeListener(new ModelTreeListener() {\n            @Override\n            public void elementChanged(ModelEvent evt) {\n                System.out.println(\"FSM-Tree::\" + evt.toString());\n            }\n        });\n```\n\nWould print a message each time something is set, added or removed in the entire FSM !\nBut, if you want to listen to events concerning the FSM only (States added or removed, don't care about Transitions and Actions), a ModelElementListener would be sufficient.\n\n``` java\nfsm.addModelElementListener(new ModelElementListener() {\n            @Override\n            public void elementChanged(ModelEvent evt) {\n                System.out.println(\"FSM::\" + evt.toString());\n            }\n        });\n```\n\n",
                "type": "Text_excerpt",
                "original_header": "Events listeners",
                "parent_header": [
                    "Model Events",
                    "API description"
                ]
            },
            "confidence": 1,
            "technique": "header_analysis",
            "source": "https://raw.githubusercontent.com/dukeboard/kevoree-modeling-framework/master/README.md"
        },
        {
            "result": {
                "type": "Text_excerpt",
                "value": "KMF has originally been developped to support the Kevoree Model@Run.time platform.\nAfter years of development for this platform, we have now acquired a strong expertise on tools needed for authoring, ditribution and synchronization of models. KMF is a generalisation of this expertise in an open and generic tool. From any domain-specific meta-model, KMF creates a specific modeling environmnent natively supplied with modeling operators compiled for JVM and JS and tuned for an efficient use at Runtime. It can be used simply host the configuration of a Software, rationalize and store data or help in the management of complex distributed Software systems. To this end, it offers the same powerful API in plain Java, and JavaScript, to ease the development of, for instance, a server-side storage in Java and its  presentation layer in a simple browser. In short, KMF generates business specific API and Tools from a metamodel, ready for distributed modeling activities. \n",
                "original_header": "Why a new framework?"
            },
            "confidence": 0.9940779911948854,
            "technique": "supervised_classification",
            "source": "https://raw.githubusercontent.com/dukeboard/kevoree-modeling-framework/master/README.md"
        },
        {
            "result": {
                "type": "Text_excerpt",
                "value": "KMF supplies runtime-oriented features such as:\n```\nmost important feature, a very simple and comprehensive API\n``` \n * Memory optimized object oriented modeling API\n * JS (Browser, NodeJS) and JVM cross-compiled models\n * Efficient visitors for models traversal\n * Unique path for each model element\n * Optimized query language to lookup model elements\n * Trace operators to atomize model operations into low-level primitive sequences \n * Built-in load/save operation in JSON/XMI format\n * Built-in clone strategies (mutable elements only, copy on write)\n * Built-in merge and diff operators\n * Persistence layer for BigModels with lazy load policy\n * Distributed datastore for BigData models\n  \n",
                "original_header": "Features"
            },
            "confidence": 0.9398517062849766,
            "technique": "supervised_classification",
            "source": "https://raw.githubusercontent.com/dukeboard/kevoree-modeling-framework/master/README.md"
        },
        {
            "result": {
                "type": "Text_excerpt",
                "value": "The Eclipse Modeling Framework(EMF) has been developed for design time manipulations of models and provides tools for this purpose, though not developed to be light, embeddable and effective at **run time**. \nThe [Kevoree Modeling Framework](https://www.google.lu/url?sa=t&rct=j&q=&esrc=s&source=web&cd=4&cad=rja&ved=0CFcQFjAD&url=http%3A%2F%2Fhal.archives-ouvertes.fr%2Fdocs%2F00%2F71%2F45%2F58%2FPDF%2Femfatruntime.pdf&ei=s8AYUfPlIZCDhQfx54DoCw&usg=AFQjCNFlfrm1NFVs6iIddxVjorbJeOajWA&sig2=nUrWedVJnv8ndOQViy2ZtA&bvm=bv.42080656,d.ZG4), or KMF, is developed specifically to address these drawbacks and provides a drop-in replacement of the EMF *generator* (i.e.: model to code generator). Indeed, models are structured data and must offer efficient solutions for their exploration, loading, saving and cloning. \n",
                "original_header": "Query language"
            },
            "confidence": 0.9824367421918998,
            "technique": "supervised_classification",
            "source": "https://raw.githubusercontent.com/dukeboard/kevoree-modeling-framework/master/README.md"
        },
        {
            "result": {
                "type": "Text_excerpt",
                "value": "Collecting model elements with a given property or simply accessing attributes of elements is one of the most common operation in modeling. But looping on relations in order to find a specific model element has serious drawbacks on performance and code complexity. Moreover the Java code generated usually offers no insurance on the uniqueness defined by the `id` attribute in the metamodel. \n**NamedElement** has an attribute `name`. This attribute is marked as the `ID` of NamedElement's elements (i.e.: the property `id` of this attribute is set to `true`).<br/>\n**ComponentModelRoot** contains several nodes.<br/>\n**Node** are NamedElements, thus has a name attribute, can contain other nodes and host components.<br/>\n**Component** are also NamedElements. \n",
                "original_header": "Path Selector"
            },
            "confidence": 0.9318056709221683,
            "technique": "supervised_classification",
            "source": "https://raw.githubusercontent.com/dukeboard/kevoree-modeling-framework/master/README.md"
        },
        {
            "result": {
                "type": "Text_excerpt",
                "value": "The API for PS is automatically included in generated classes for each model element that declares an `ID` attribute.\nIn this case, two methods are automatically generated : find**relationshipName**ByID and findByPath method.\n``` java\nNode findNodeByID(String nodeID); \t\nObject findByPath(String query); \n```\n \n",
                "original_header": "Path API"
            },
            "confidence": 0.980852279046466,
            "technique": "supervised_classification",
            "source": "https://raw.githubusercontent.com/dukeboard/kevoree-modeling-framework/master/README.md"
        },
        {
            "result": {
                "type": "Text_excerpt",
                "value": "When working with models, the selection of elements among a collection is one of the most common operation. This selection is often made of a filter on the values of some elements' attributes. This filtered sub-collection can then be applied another filter going deeper in the containment relation and/or a treatment can be applied. \nKMFQL-QS relies on [JFilter](https://github.com/rouvoy/jfilter) for the definition of filters and execution of the query.\n \n",
                "original_header": "Query Selector"
            },
            "confidence": 0.956158911482444,
            "technique": "supervised_classification",
            "source": "https://raw.githubusercontent.com/dukeboard/kevoree-modeling-framework/master/README.md"
        },
        {
            "result": {
                "type": "Text_excerpt",
                "value": "The relation name is optional. In this case,  the query is executed on **ALL** relations of the element on which it is called.<br/> \n",
                "original_header": "Selector syntax"
            },
            "confidence": 0.9320262318342661,
            "technique": "supervised_classification",
            "source": "https://raw.githubusercontent.com/dukeboard/kevoree-modeling-framework/master/README.md"
        },
        {
            "result": {
                "type": "Text_excerpt",
                "value": "As for KMFQL-PS, selector methods are generated directly in the classes of the model elements, if the `selector` option is set to true in the KMF maven plugin. \n",
                "original_header": "Selector API"
            },
            "confidence": 0.937507473268512,
            "technique": "supervised_classification",
            "source": "https://raw.githubusercontent.com/dukeboard/kevoree-modeling-framework/master/README.md"
        },
        {
            "result": {
                "type": "Text_excerpt",
                "value": "Events are handy to be informed about changes in models each time they occur. This mechanism can be used to synchronize models or to synchronize a view with it's backbone model. Basically an event listener can be registerd on a specific model element or recursively on all sub-contained elements *(tree listener)*.\n \n",
                "original_header": "Events motivation"
            },
            "confidence": 0.9057657106305764,
            "technique": "supervised_classification",
            "source": "https://raw.githubusercontent.com/dukeboard/kevoree-modeling-framework/master/README.md"
        },
        {
            "result": {
                "type": "Text_excerpt",
                "value": "The classical approach in model object oriented API is based on iterations on lists to perform this naviguation. This leads to serious performance drawbacks due to potentially huge number of temporary object created during this iterative process. For this reason KMF generates a built-in very efficient visitor pattern to go through all modelelements, relationships and attributes.\n \n",
                "original_header": "Efficient visit"
            },
            "confidence": 0.9765957781493445,
            "technique": "supervised_classification",
            "source": "https://raw.githubusercontent.com/dukeboard/kevoree-modeling-framework/master/README.md"
        },
        {
            "result": {
                "type": "Text_excerpt",
                "value": "Need an example ? This is a trace to set the attribute `param` of the `node0` element of the `nodes` relation to `newVal`. This trace is also generated when the attribute is set. \n",
                "original_header": "What is a trace?"
            },
            "confidence": 0.9611391137567934,
            "technique": "supervised_classification",
            "source": "https://raw.githubusercontent.com/dukeboard/kevoree-modeling-framework/master/README.md"
        },
        {
            "result": {
                "type": "Text_excerpt",
                "value": "Once create, a Model tracker is activated by calling the **track** method with the element you wanna track in parameter. To stop the tracking, a simple call to **untrack** method is required. The **reset** method allows to define a break point in the tracker. User can then perform any modifications on models. A call of the **undo** method applies the reversed trace sequence, which reverts all modifications. After that, a call to **redo** method applies again the modifications. \n",
                "original_header": "Undo/Redo for models"
            },
            "confidence": 0.9272777969213654,
            "technique": "supervised_classification",
            "source": "https://raw.githubusercontent.com/dukeboard/kevoree-modeling-framework/master/README.md"
        },
        {
            "result": {
                "type": "Text_excerpt",
                "value": "The MOF structure of your models like described in .ecore files only reflects the structural way to store models. Though Ecore allows you to define operations into models, the core of these operations can not be properly described directly in the model, because it depends on the target language of the generation. \nKMF relies on the Kotlin language to express the core of operations. Kotlin language can be cross-compiled to JS and JVM, making the method core seemlessly working in Java and JavaScript (for browser or nodejs platforms).\nIn KMF, the synchronization between code and model (ecore files) is partially bi-directional. The skeletons of methods are generated from the operations declared in the model, which eases the completion of the behavioral code of operations. In the other way, any method added next to a generated method and any new class declared in the code, is automatically added in the meta-model. \nUse code or model first as needed in your project, but please remind that models are made to abstract and define the domain concepts; technical details should be hidden in code.\n \n",
                "original_header": "Modeling through code"
            },
            "confidence": 0.9586796309704231,
            "technique": "supervised_classification",
            "source": "https://raw.githubusercontent.com/dukeboard/kevoree-modeling-framework/master/README.md"
        },
        {
            "result": {
                "type": "Text_excerpt",
                "value": "The KMF maven plugin generates into the target directory a file named : <artefactID>.min.js.\nThis file is ready to be included as a nodeJS module. To load it, you only have to call the include directive of nodeJS. Of course replace `org.cloud` by the generated package specified in your model.\n``` js\nvar model = require('./org.kevoree.modeling.sample.cloud.js.min.js');\nvar saver = new model.org.cloud.serializer.JSONModelSerializer();\nvar loader = new model.org.cloud.loader.JSONModelLoader();\n```\n \n",
                "original_header": "in NodeJS"
            },
            "confidence": 0.9471234661005977,
            "technique": "supervised_classification",
            "source": "https://raw.githubusercontent.com/dukeboard/kevoree-modeling-framework/master/README.md"
        },
        {
            "result": {
                "type": "Text_excerpt",
                "value": "Models can reach a huge size, especially when using it to store the monitored history of a system or while modeling a domain of use such as all the possible topologies of a cluster of machines. In such case study, models can not fit in memory anymore and we need a better way to interact with informations. Similarly to BigData we speak of BigModel in such cases.\n \n",
                "original_header": "What is BigModel ?"
            },
            "confidence": 0.9200792582466242,
            "technique": "supervised_classification",
            "source": "https://raw.githubusercontent.com/dukeboard/kevoree-modeling-framework/master/README.md"
        },
        {
            "result": {
                "type": "Text_excerpt",
                "value": "KMF Persistence API is based on the following asumption: despite a model does not fit in memory, or is stored on a remote server, its authoring must be exactly identical to the in memory authoring. The main concept behind the KMF persistence layer is the lazy load. In short, the model seamlessly loads model elements on demand, when required by the navigation in the model. If a model element is created in memory or already loaded, a cache will optimizes the load. To reduce the space in memory, an element is loaded only if its path is looked for. Moreover, the attributes and referenced elements are loaded only if a get or a set is performed on one of them. This concept allows to go directly in deep in the graph object without any extra-cost like a select in a database.\n \n",
                "original_header": "Concept overview"
            },
            "confidence": 0.9298182712182531,
            "technique": "supervised_classification",
            "source": "https://raw.githubusercontent.com/dukeboard/kevoree-modeling-framework/master/README.md"
        },
        {
            "result": {
                "type": "Text_excerpt",
                "value": "The main entry point for the persistence KMF API is a special factory : PersistenceKMFFactory. This factory allows to interact with the BigModel through the lookup of elements using their path, and the save of elements using the persist method. A simple batch concept allows to save several elements shortly. All modifications are actually written to the remote storage or disk only when a call on **commit** method is performed. Finally the **clearCache** method allows to close the factory and free the memory.\n``` java\ntrait PersistenceKMFFactory {\n\tfun lookup(path: String): KMFContainer?\n\tfun persist(elem: KMFContainer)\n\tfun persistBatch(batch: Batch)\n\tfun createBatch()\n\tfun commit()\n\tfun clearCache()\n}\n```\n \n",
                "original_header": "PersistenceFactory"
            },
            "confidence": 0.9503598413701484,
            "technique": "supervised_classification",
            "source": "https://raw.githubusercontent.com/dukeboard/kevoree-modeling-framework/master/README.md"
        }
    ],
    "name": [
        {
            "result": {
                "value": "kevoree-modeling-framework",
                "type": "String"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "full_name": [
        {
            "result": {
                "value": "dukeboard/kevoree-modeling-framework",
                "type": "String"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "issue_tracker": [
        {
            "result": {
                "value": "https://api.github.com/repos/dukeboard/kevoree-modeling-framework/issues",
                "type": "Url"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "forks_url": [
        {
            "result": {
                "value": "https://api.github.com/repos/dukeboard/kevoree-modeling-framework/forks",
                "type": "Url"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "stargazers_count": [
        {
            "result": {
                "value": 36,
                "type": "Number"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "keywords": [
        {
            "result": {
                "value": "",
                "type": "String"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "forks_count": [
        {
            "result": {
                "value": 7,
                "type": "Number"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "download_url": [
        {
            "result": {
                "value": "https://github.com/dukeboard/kevoree-modeling-framework/releases",
                "type": "Url"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "programming_languages": [
        {
            "result": {
                "value": "JavaScript",
                "name": "JavaScript",
                "type": "Programming_language",
                "size": 7478434
            },
            "confidence": 1,
            "technique": "GitHub_API"
        },
        {
            "result": {
                "value": "Java",
                "name": "Java",
                "type": "Programming_language",
                "size": 803711
            },
            "confidence": 1,
            "technique": "GitHub_API"
        },
        {
            "result": {
                "value": "TypeScript",
                "name": "TypeScript",
                "type": "Programming_language",
                "size": 636030
            },
            "confidence": 1,
            "technique": "GitHub_API"
        },
        {
            "result": {
                "value": "HTML",
                "name": "HTML",
                "type": "Programming_language",
                "size": 34808
            },
            "confidence": 1,
            "technique": "GitHub_API"
        },
        {
            "result": {
                "value": "Objective-C++",
                "name": "Objective-C++",
                "type": "Programming_language",
                "size": 9069
            },
            "confidence": 1,
            "technique": "GitHub_API"
        },
        {
            "result": {
                "value": "Shell",
                "name": "Shell",
                "type": "Programming_language",
                "size": 2138
            },
            "confidence": 1,
            "technique": "GitHub_API"
        },
        {
            "result": {
                "value": "CSS",
                "name": "CSS",
                "type": "Programming_language",
                "size": 1201
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "has_script_file": [
        {
            "result": {
                "value": "https://raw.githubusercontent.com/dukeboard/kevoree-modeling-framework/master/releaseScript.sh",
                "type": "Url"
            },
            "confidence": 1,
            "technique": "file_exploration"
        },
        {
            "result": {
                "value": "https://raw.githubusercontent.com/dukeboard/kevoree-modeling-framework/master/install.sh",
                "type": "Url"
            },
            "confidence": 1,
            "technique": "file_exploration"
        },
        {
            "result": {
                "value": "https://raw.githubusercontent.com/dukeboard/kevoree-modeling-framework/master/deploy.sh",
                "type": "Url"
            },
            "confidence": 1,
            "technique": "file_exploration"
        },
        {
            "result": {
                "value": "https://raw.githubusercontent.com/dukeboard/kevoree-modeling-framework/master/documentation/run.sh",
                "type": "Url"
            },
            "confidence": 1,
            "technique": "file_exploration"
        },
        {
            "result": {
                "value": "https://raw.githubusercontent.com/dukeboard/kevoree-modeling-framework/master/documentation/build.sh",
                "type": "Url"
            },
            "confidence": 1,
            "technique": "file_exploration"
        }
    ],
    "readme_url": [
        {
            "result": {
                "value": "https://raw.githubusercontent.com/dukeboard/kevoree-modeling-framework/master/README.md",
                "type": "Url"
            },
            "confidence": 1,
            "technique": "file_exploration"
        }
    ],
    "documentation": [
        {
            "result": {
                "value": "https://github.com/dukeboard/kevoree-modeling-framework/tree/master/documentation/docs",
                "type": "Url"
            },
            "confidence": 1,
            "technique": "file_exploration"
        },
        {
            "result": {
                "type": "Url",
                "value": "https://github.com/dukeboard/kevoree-modeling-framework/wiki",
                "format": "wiki"
            },
            "confidence": 1,
            "technique": "regular_expression",
            "source": "https://raw.githubusercontent.com/dukeboard/kevoree-modeling-framework/master/README.md"
        }
    ],
    "usage": [
        {
            "result": {
                "value": "---------------\n\nThe Apache Maven dependencies and plugin management system is probably the easiest way to start using KMF.\nYou can complete one of your existing project with the configuration that comes next, or simply follow the kick-off sample project provided here.\n\n> NB : standalone compiler and NetBeans/Eclipse/IntelliJ plugins are coming soon !\n",
                "type": "Text_excerpt",
                "original_header": "Getting started",
                "parent_header": [
                    "Kevoree Modeling"
                ]
            },
            "confidence": 1,
            "technique": "header_analysis",
            "source": "https://raw.githubusercontent.com/dukeboard/kevoree-modeling-framework/master/README.md"
        },
        {
            "result": {
                "value": "Create a Maven project folder in which you will place the pom and your EcoreMM.\n\n```\nmyProject\n |-myMetaModel.ecore\n |-pom.xml\n```\n\nThen the KMF plugin in the Build/Plugins section\n\n``` html\n<plugin>\n <groupId>org.kevoree.modeling</groupId>\n <artifactId>org.kevoree.modeling.kotlin.generator.mavenplugin</artifactId>\n <version>replace.by.last.kmf.version</version>\n <extensions>true</extensions>\n <executions><execution>\n   <id>ModelGen</id>\n   <goals><goal>generate</goal></goals>\n   <configuration>\n   \n   </configuration>\n  </execution></executions>\n</plugin>\n```\n\nIn addition, add the KMF MicroFramework dependency\n``` html\n<dependency>\n <groupId>org.kevoree.modeling</groupId>\n <artifactId>org.kevoree.modeling.microframework</artifactId>\n <version>replace.by.last.kmf.version</version>\n</dependency>\n```\n",
                "type": "Text_excerpt",
                "original_header": "Using your own maven project",
                "parent_header": [
                    "Kevoree Modeling",
                    "Getting started"
                ]
            },
            "confidence": 1,
            "technique": "header_analysis",
            "source": "https://raw.githubusercontent.com/dukeboard/kevoree-modeling-framework/master/README.md"
        },
        {
            "result": {
                "value": "If you don't have an existing project you can download one by clicking on the button.\n\n> [Download sample project >](https://github.com/kevoree/kmf-samples/tree/master/tinycloud)\n",
                "type": "Text_excerpt",
                "original_header": "Using a sample project",
                "parent_header": [
                    "Kevoree Modeling",
                    "Getting started"
                ]
            },
            "confidence": 1,
            "technique": "header_analysis",
            "source": "https://raw.githubusercontent.com/dukeboard/kevoree-modeling-framework/master/README.md"
        },
        {
            "result": {
                "value": "When your Maven project is ready, just open a terminal, cd into the folder containing the pom file and type in the following command.\n\n```\nmvn clean install\n```\n\nAfter compilation, the target folder contains a JAR or a JS file of the modeling API. The next step is to include the .js file into a web page (or NodeJS) or add the project as a dependency of your application to start Modeling@Runtime using the concepts you defined in the MetaModel.\n\n\n",
                "type": "Text_excerpt",
                "original_header": "Compile models",
                "parent_header": [
                    "Kevoree Modeling",
                    "Getting started"
                ]
            },
            "confidence": 1,
            "technique": "header_analysis",
            "source": "https://raw.githubusercontent.com/dukeboard/kevoree-modeling-framework/master/README.md"
        },
        {
            "result": {
                "value": "Events are optionaly included in the generated API. To activate events, simply set the `event` option of the KMF Maven pluggin to `true`. The generator includes all necessary methods and classes to provide a listener mechanism to all the features of your Metamodel.\n\n``` xml\n   <events>true</events>\n```\n",
                "type": "Text_excerpt",
                "original_header": "How to uses it ?",
                "parent_header": [
                    "Model Events",
                    "What for?"
                ]
            },
            "confidence": 1,
            "technique": "header_analysis",
            "source": "https://raw.githubusercontent.com/dukeboard/kevoree-modeling-framework/master/README.md"
        },
        {
            "result": {
                "value": "The KMF visitor API is based on the ModelVisitor interface. It is mainly based on a visit method called each time a visitor (custom process) finds a new element to visit.\n\n``` java\npackage org.kevoree.modeling.api.util;\ntrait ModelVisitor {\n\tfun visit(elem : KMFContainer, refInParent : String, parent : KMFContainer)\n}\n```\n\nIn addition, a visitor can optionaly define additional methods to have feedback during the visit. The beginVisitElem method is called just before the visit of an element starts, respectively the endVisitElem method is called just after the visit of an element is completed (i.e.: when this object and all its child elements have been visited). Also, beginVisitRef and endVisitRef are called when a reference of an element is visited. The endVisitRef method is called when all elements of a reference have been visited.\n\n\n``` java\nfun beginVisitElem(elem : KMFContainer){}\nfun endVisitElem(elem : KMFContainer){}\nfun beginVisitRef(refName : String, refType : String){}\nfun endVisitRef(refName : String){}\n```\n\nDespite its efficiency to traverse a model, the recursion of the visitor sometimes needs to be controled to optimize the visitor's performance. For this purpose, the ModelVisitor is decorated with a `stopVisit` method, to abort the visit, and a `noChildrenVisit` and `noReferencesVisit` to respectivelly avoid the visit of the contained elements and the visit of referenced model elements.\n\n``` java\nfun stopVisit()\nfun noChildrenVisit()\nfun noReferencesVisit()\n```\n\nTo visit the attributes of a model element, KMF provides a dedicated model visitor named ModelAttributeVisitor. The `visit`method of this visitor is called for each attribute of a model elements, with the content (value) and the name of the attribute.\n\n```\ntrait ModelAttributeVisitor {\n\tfun visit(value: Any?, name: String, parent: KMFContainer)\n}\n```\n",
                "type": "Text_excerpt",
                "original_header": "Visitors API",
                "parent_header": [
                    "Model visitors",
                    "Visitor usage"
                ]
            },
            "confidence": 1,
            "technique": "header_analysis",
            "source": "https://raw.githubusercontent.com/dukeboard/kevoree-modeling-framework/master/README.md"
        },
        {
            "result": {
                "value": "Any KMF model element as two built-in methods to start a visit. The `visit` method takes your custom visitor as first parameter. The second parameter allows to define if the visit is recursive; the third specifies if it should include the contained elements and the last parameter if not-contained references has to be visited.\nFinally, the visitAttributes allows to trigger a visit of attributes on a model element.\n\n``` java\ntrait KMFContainer {\n \tfun visit(visitor : org.kevoree.modeling.api.util.ModelVisitor, \n\t\trecursive : Boolean, containedReference : Boolean,\n\t\tnonContainedReference : Boolean)\n\tfun visitAttributes(visitor : ModelAttributeVisitor)\n}\n```\n",
                "type": "Text_excerpt",
                "original_header": "How to use?",
                "parent_header": [
                    "Model visitors",
                    "Visitor usage"
                ]
            },
            "confidence": 1,
            "technique": "header_analysis",
            "source": "https://raw.githubusercontent.com/dukeboard/kevoree-modeling-framework/master/README.md"
        }
    ],
    "installation": [
        {
            "result": {
                "value": "To perform all KMF model operation, we need to generated a trace sequence through a model compare. This trace sequence can be then apply on a model to perform the real operation. \n\n```\nModelCompare compare = new DefaultModelCompare();\n```\n",
                "type": "Text_excerpt",
                "original_header": "ModelCompare",
                "parent_header": [
                    "Model operators",
                    "Set operations on models"
                ]
            },
            "confidence": 1,
            "technique": "header_analysis",
            "source": "https://raw.githubusercontent.com/dukeboard/kevoree-modeling-framework/master/README.md"
        },
        {
            "result": {
                "value": "A model merge operation aims at merge all models elements present in two models in one model. \n\n> A + TraceMergeOf(A,B) = A + B\n\nAs all KMF model operation it relie on the comparator to generate the trace sequence corresding to such operation. Then the trace sequence can be apply on A, B is unchanged.\n\n``` java\ndiffSeq = compare.merge(modelA,modelB);\ndiffSeq.applyOn(modelA)\n```\n",
                "type": "Text_excerpt",
                "original_header": "Model union",
                "parent_header": [
                    "Model operators",
                    "Set operations on models"
                ]
            },
            "confidence": 1,
            "technique": "header_analysis",
            "source": "https://raw.githubusercontent.com/dukeboard/kevoree-modeling-framework/master/README.md"
        },
        {
            "result": {
                "value": "A model intersection operation aims at building a model containing all common models elements present in two models. \n\n> A + TraceMergeOf(A,B) = (A+B) - A - B \n\nAs all KMF model operation it relie on the comparator to generate the trace sequence corresding to such operation.\n\n``` java\ndiffSeq = compare.inter(modelA,modelB);\ndiffSeq.applyOn(modelA)\n```\n",
                "type": "Text_excerpt",
                "original_header": "Model intersection",
                "parent_header": [
                    "Model operators",
                    "Set operations on models"
                ]
            },
            "confidence": 1,
            "technique": "header_analysis",
            "source": "https://raw.githubusercontent.com/dukeboard/kevoree-modeling-framework/master/README.md"
        },
        {
            "result": {
                "value": "A model compare operation aims at migrate a model to another. In short a model A should reach the state of a model B this is the right operation. This operation is mainly used in synchronization process. \n\n> A + TraceMergeOf(A,B) = B\n\nAs all KMF model operation it relie on the comparator to generate the trace sequence corresding to such operation.\n\n``` java\ndiffSeq = compare.inter(modelA,modelB);\ndiffSeq.applyOn(modelA)\n```\n",
                "type": "Text_excerpt",
                "original_header": "Model patch",
                "parent_header": [
                    "Model operators",
                    "Set operations on models"
                ]
            },
            "confidence": 1,
            "technique": "header_analysis",
            "source": "https://raw.githubusercontent.com/dukeboard/kevoree-modeling-framework/master/README.md"
        },
        {
            "result": {
                "type": "Text_excerpt",
                "value": "Now, imagine that you want to get the `logger`component that you know to be hosted on node `42`. Doing so using the KMF API looks like:\n``` java\nComponentModelRoot root = mySystem.getRoot();\nComponent foundComponent = null;\nfor(Node loopingNode : root.getNodes()){\n\tif(loopingNode.getName().equals(\"42\")){\n\t\tfor(Component loopingComponent : loopingNode.getComponents()){\n\t\t\tif(loopingComponent.equals(\"logger\")){\n\t\t\t\tfoundComponent = loopingComponent.equals;\n\t\t\t}\n    \t}\n\t}\t\n}\n```\nUsing the KMFQL-PS the same research looks like:\n``` java\nComponentModelRoot root = mySystem.getRoot();\nComponent foundComponent = root.findByPath(\"nodes[42]/components[logger]\");\n```\t\n \n",
                "original_header": "Path Selector"
            },
            "confidence": 0.9946322382131797,
            "technique": "supervised_classification",
            "source": "https://raw.githubusercontent.com/dukeboard/kevoree-modeling-framework/master/README.md"
        },
        {
            "result": {
                "type": "Text_excerpt",
                "value": "Let's take as example a simple FSM metamodel (you can find it [here](https://github.com/kevoree/kmf-samples/tree/master/fsm/org.kevoree.modeling.sample.fsm.kt) ). In this metamodel we add an operation `run` to the metaclass `Action`. Then, you can declare in your src/main/java directory several Kotlin traits implementing the generated interface. An example can be found [here](https://github.com/kevoree/kmf-samples/blob/master/fsm/org.kevoree.modeling.sample.fsm.kt/src/main/java/org/jetbrains/annotations/MyAspect.kt).\n``` kotlin\naspect trait MyAspect : Action {\n\toverride fun run(p : Boolean): String {return \"\";}\n\tprivate fun internalStuff(){}\n    }\n```\n \n",
                "original_header": "Aspect API"
            },
            "confidence": 0.9425577705156966,
            "technique": "supervised_classification",
            "source": "https://raw.githubusercontent.com/dukeboard/kevoree-modeling-framework/master/README.md"
        }
    ],
    "application_domain": [
        {
            "result": {
                "type": "String",
                "value": "Semantic web"
            },
            "confidence": 0.9547470568900229,
            "technique": "supervised_classification"
        }
    ],
    "full_title": [
        {
            "result": {
                "type": "String",
                "value": "The Kevoree Modeling organization has moved to a new repository =&gt; https://github.com/kevoree-modeling see you there !"
            },
            "confidence": 1,
            "technique": "regular_expression",
            "source": "https://raw.githubusercontent.com/dukeboard/kevoree-modeling-framework/master/README.md"
        }
    ],
    "images": [
        {
            "result": {
                "type": "Url",
                "value": "https://raw.raw.githubusercontent.com/dukeboard/kevoree-modeling-framework/master/doc/fig/minikev.png"
            },
            "confidence": 1,
            "technique": "regular_expression",
            "source": "https://raw.githubusercontent.com/dukeboard/kevoree-modeling-framework/master/README.md"
        }
    ]
}