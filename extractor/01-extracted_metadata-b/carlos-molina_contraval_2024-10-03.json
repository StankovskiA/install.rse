{
    "somef_provenance": {
        "somef_version": "0.9.5",
        "somef_schema_version": "1.0.0",
        "date": "2024-10-03 20:01:28"
    },
    "code_repository": [
        {
            "result": {
                "value": "https://github.com/carlos-molina/contraval",
                "type": "Url"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "owner": [
        {
            "result": {
                "value": "carlos-molina",
                "type": "User"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "date_created": [
        {
            "result": {
                "value": "2013-05-25T22:09:35Z",
                "type": "Date"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "date_updated": [
        {
            "result": {
                "value": "2023-11-27T09:50:59Z",
                "type": "Date"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "description": [
        {
            "result": {
                "value": "A tool for validating the logical consistency of smart contracts implemented at Newcastle Univ. and maintained by Univ. of Cambridge.",
                "type": "String"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        },
        {
            "result": {
                "type": "Text_excerpt",
                "value": "Reliability is an attribute of a system, of a \nsmart contract in this discussion, and defines\nits continuity of correct service. Thus my smart\ncontract is reliable if it is capable of \nmonitoring or enforcing  \ncontractual interactions continuously\nand correctly. This means that a realiable smart\ncontract does not crash or produce incorrect\nverdicts.\n \n",
                "original_header": "Is your smart contract reliable?"
            },
            "confidence": 0.9913319456739852,
            "technique": "supervised_classification",
            "source": "https://raw.githubusercontent.com/carlos-molina/contraval/master/README.md"
        },
        {
            "result": {
                "type": "Text_excerpt",
                "value": "To appreciate validation,\nit is worth bearing in mind that a smart contract\nis a model of the original legal contract\nsigned between the contracting parties. Such\na model is expressed at different levels of\nabstractions ranging from high level normative\nstatements to execution code, such as Ethereum EVM\nbytecode. Each model (strictly speaking, each\nversion of the model) is liable to errors that\ncorrespond to its level of abstraction.  \n\n**Implementation time models:** an implementation\ntime model is liable to errors related to the implementation \nlanguage and to the mapping that the programmer implements\nto convert the abstract model of the smart contract into\nexecutable code. The programmer needs skill to interprete the\nabstract model of the smart contract correctly and to\nmap it accurately.  For example, smart contracts implemented \nin Solidity language are known to be at risk of being\nafflicted by reentrancy, unchecked send, integer\noverflow, and other language related errors. See for example,\n[ZEUS: Analyzing Safety of Smart Contracts, Sukrit at. al.](http://wp.internetsociety.org/ndss/wp-content/uploads/sites/25/2018/02/ndss2018_09-1_Kalra_paper.pdf \"ZEUS paper\"). \n\n**Mapping from model into model*** Errors (precisely faults) \n  are likely to be included during the building of the  models \n  themselves and during the conversion (mapping) from one model into the\n  next model below. This is due to the semantic\n  gap between models represented at different levels\n  of abstractions; mapping from one statement at\n  a given model to the next model below is not one-to-one,\n  but many-to-many. See for example,\n  [Establishing Conformance Between Contracts and Choreographies, Carlos Molina-Jimenez, at. al.](https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=6642860 \"Vienna paper\"). Even if the mapping is correct, \n  sometimes it becomes relevant to learn, how did the\n  programmer map a given statement into implementation\n  code, out of several correct alternatives? \n1. Include exception handling in the design of the smart contract\n   under development. Exception handling should be central to \n   your design rather than an afterthought component.  \n2. Build an abstract model of the smart contract and model\n   check it with your favourite model checker, with one\n   that has been specifically designed (or tuned to) for model checking\n   smart contracts--if you have one.\n   This is the stage where you need to verify that you \n   have not forgotten execution paths and that you have included\n   logic to react to both normal and abnormal (exceptional)\n   situations. For example, check that if a cancellation\n   takes place, the smart contract will not complete before\n   the buyer is refunded. Check that the smart contract\n   does not allow the seller to double charge the buyer\n   or that the latter does not get items for free.\n3. Build the executable model of your smart contract and\n   test it. There are other techniques that can be used\n   for verification of executable code (for example,\n   symbolic execution) but we are following \n   testing here. Test (exercise) the actual \n   implementation deployed in the actual infrastructure. If\n   possible, exercise all the executions sequences encoded\n   in the smart contract--this is perfectly possible for \n   small contracts.\n   Do not forget to verify that the executable smart\n   contract conforms to the highest model of the\n   smart contract--likely to be in plain English business\n   language.  \nIt is worth clarifying that these are standard software\nengineering techniques for building reliable systems\nand are referred to as fault-tolerance techniques.\nHowever, perhaps due to the novelty of blockchain-based\napplications, they have been largely ignored by developers\nof smart contracts. This comes as a surprise as a salient\nparticularity of smart contracts (in particular those\ndeployed on--blockchains) is that once deployed, they\nare very hard to amend.  \n",
                "original_header": "Smart contract models"
            },
            "confidence": 0.961283573612149,
            "technique": "supervised_classification",
            "source": "https://raw.githubusercontent.com/carlos-molina/contraval/master/README.md"
        },
        {
            "result": {
                "type": "Text_excerpt",
                "value": "As shown in the figure,  we rely on exception handling\nwith formal validation of smart contracts. Notice that\nthe box of the *exceptional smart contract behaviour* is\nlarger than the box of *normal smart contract behaviour*. We\nhave drawn them like that to underline the fact that\nexception handling code represents a large porcentage\nof the whole code-some authors claim that it can be\nas large as up to two-thirds. \nOnce the abstract model of the smart contract is\nbuilt, we model check and test it systematically to uncover and\nremove faults.  We stress that the programmer is\nlikely to produce an unreliable executable smart\ncontract out of a realiable abstract model. We\nintroduce testing to uncover and remove potential\nfaults. Though not shown in the figure, the *faults uncovered*\narrows are meant to trigger correction \nand re-examination of the corresponding models.  \n",
                "original_header": "Validation of smart contract models to remove faults"
            },
            "confidence": 0.9655504353712319,
            "technique": "supervised_classification",
            "source": "https://raw.githubusercontent.com/carlos-molina/contraval/master/README.md"
        },
        {
            "result": {
                "type": "Text_excerpt",
                "value": "A particularity of smart contracts deployed on--blockchain \nis that because of their descentralisation and openess, \nthey are hard to amend after deployment. Therefore, we \nsuggest that smart contracts are thoroughly validated \n(for example, using conventional model checking tools) \nto uncover potential logical inconsistencies of their clauses \n(omissions, contradictions, duplications, etc.). In addition, \nwe suggest that the actual implementation is systematically \ntested before deployment. In hybrid architectures \n(see for example,\n[Implementation of Smart Contracts Using Hybrid Architectures with On- and Off-Blockchain Components](https://arxiv.org/pdf/1808.00093.pdf \"implementation paper\"))\nthat include on and off--blockchain components the risk of \nimplementing buggy is exacerbated by the interaction between \nthe the components. \n",
                "original_header": "Validate your smart contracts before deployment"
            },
            "confidence": 0.9571982784360518,
            "technique": "supervised_classification",
            "source": "https://raw.githubusercontent.com/carlos-molina/contraval/master/README.md"
        },
        {
            "result": {
                "type": "Text_excerpt",
                "value": " Spin can be instructed to generate all the execution\n sequences encoded in the epromela model of the\n smart contract. The basic idea is to use Spin as a\n generator of counterexamples produced against \n LTL formulae.\n \n",
                "original_header": "Generation of execution sequences (test cases) for conformance testing"
            },
            "confidence": 0.9270044749173487,
            "technique": "supervised_classification",
            "source": "https://raw.githubusercontent.com/carlos-molina/contraval/master/README.md"
        },
        {
            "result": {
                "type": "Text_excerpt",
                "value": "At the heart of epromela lies a Business Event\nGenerator (BEG) that is responsible for \ngenerating the events that correspond to the\nexecution of contractual operations.  \nAs shown in the figure, the execution of each contractual \noperation results in the exchange of messages between the two \ncontractual parties. A copy of each message can be sent to third \nparties (for example, to a smart contract) as shown in the \nfigure. \n",
                "original_header": "Business Event Generator of epromela"
            },
            "confidence": 0.9084467513520815,
            "technique": "supervised_classification",
            "source": "https://raw.githubusercontent.com/carlos-molina/contraval/master/README.md"
        },
        {
            "result": {
                "type": "Text_excerpt",
                "value": "To agree on the outcome of each operation and be able\nto progress to the next one in harmony, the parties\nrely on an output synchronizer that is responsible for \nreceiving the individual outcomes, compute a single\noutcome and notify it to the contractual parties and\npossibly to other parties that are entitled to\nfollow the execution of the contract. \n",
                "original_header": "Execution model of bilateral operations with potential exceptions"
            },
            "confidence": 0.9584272403866694,
            "technique": "supervised_classification",
            "source": "https://raw.githubusercontent.com/carlos-molina/contraval/master/README.md"
        },
        {
            "result": {
                "type": "Text_excerpt",
                "value": "Once the designer is satisfied about the correctness\nof the epromela model of the smart contract,\nhe can proceed to implement it in a language\nfor coding smart contracts, deploy and execute it. \n",
                "original_header": "4. Implementation, deployment and execution of smart contracts"
            },
            "confidence": 0.9502728274326334,
            "technique": "supervised_classification",
            "source": "https://raw.githubusercontent.com/carlos-molina/contraval/master/README.md"
        }
    ],
    "name": [
        {
            "result": {
                "value": "contraval",
                "type": "String"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "full_name": [
        {
            "result": {
                "value": "carlos-molina/contraval",
                "type": "String"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "issue_tracker": [
        {
            "result": {
                "value": "https://api.github.com/repos/carlos-molina/contraval/issues",
                "type": "Url"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "forks_url": [
        {
            "result": {
                "value": "https://api.github.com/repos/carlos-molina/contraval/forks",
                "type": "Url"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "stargazers_count": [
        {
            "result": {
                "value": 2,
                "type": "Number"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "keywords": [
        {
            "result": {
                "value": "",
                "type": "String"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "forks_count": [
        {
            "result": {
                "value": 3,
                "type": "Number"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "download_url": [
        {
            "result": {
                "value": "https://github.com/carlos-molina/contraval/releases",
                "type": "Url"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "readme_url": [
        {
            "result": {
                "value": "https://raw.githubusercontent.com/carlos-molina/contraval/master/README.md",
                "type": "Url"
            },
            "confidence": 1,
            "technique": "file_exploration"
        }
    ],
    "documentation": [
        {
            "result": {
                "value": "https://github.com/carlos-molina/contraval/tree/master/docs",
                "type": "Url"
            },
            "confidence": 1,
            "technique": "file_exploration"
        },
        {
            "result": {
                "type": "Url",
                "value": "https://github.com/carlos-molina/contraval/wiki",
                "format": "wiki"
            },
            "confidence": 1,
            "technique": "regular_expression",
            "source": "https://raw.githubusercontent.com/carlos-molina/contraval/master/README.md"
        }
    ],
    "usage": [
        {
            "result": {
                "value": "Smart contracts are complex systems and as such\nare likely to contain design and implementation\nfaults that will eventually \nmanifiest as run--time errors. These errors will \nderail the smart contracts from its normal expected \nbehaviour or crash it.\n\n**Errors and faults:** To follow precise terminology (see for example,\n[Basic Concepts and Taxonomy of Dependable\nand Secure Computing, Algirdas et. al.](http://www.cs.ncl.ac.uk/research/pubs/articles/papers/666.pdf \"Brian Randell paper at Ncl\"))\nI should distinguish between faults and errors; however, since the \nuse of the two terms as synonymous is widely spread,\nI will not insist in the distintion, except where\nstrictly necessary. Intuitively speaking, a fault\nis a dormant error, for example,\nan erroneous line of the Java code that has not\nbeen activated in the execution because some \nif-conditions have not been satisfied yet.\n</br>\n",
                "type": "Text_excerpt",
                "original_header": "What can go wrong with a smart contract?",
                "parent_header": [
                    "1.- How to build reliable smart contracts"
                ]
            },
            "confidence": 1,
            "technique": "header_analysis",
            "source": "https://raw.githubusercontent.com/carlos-molina/contraval/master/README.md"
        },
        {
            "result": {
                "value": "The smart contract oriented primitives provided by epromela \nhelp developers build models\nthat describe the behaivour of contractual interactions in an\nintuitive manner. The figure bellow shows the two main\ncomponents of an epromela model, namely, the *BEG* and\nthe *set of rules*. It is based on the contract example,\nconsequently, the set of rules (stored in the *rules.h*\nfiles) includes only two rules, one for each \nbusiness operation.\n\nThe two rules include the contruct *IS_O*, where *O* stands \nfor obligation, therefore, the construct reads _is obligation_.\n*IS_O* is an illustrative example of the contract oriented primitives\nthat epromela offers. In *Rule(pay)*, *IS_O* indicates that\nthe rule will trigger only when it receives\nthe event *pay* and the buyer has a pending obligation\nto pay.\n\n<p align=\"center\">\n  <img src=\"./figures/epromelaModelOfBuyerStoreContractOutputTO.png\" \n   width=\"400\" title=\"epromela model of the buyer-store example with\n                      output TO.\">\n</p>\n\nIf you are motivated to run the hello world contract world example,\nyou can find the complete code (and instructions to run it)\nat the [example/helloWorldSmartContract](https://github.com/carlos-molina/contraval/tree/master/examples/helloWorldSmartContractExecOutSuccessOrTO) folder.\nA run of the model will mechanically produce all (three) the execution\nsequences encoded in the model, namely:\n\n```\n- payto\n- pay -> ack\n- pay -> ackto\n```\nWhere *payto* and *ackto* stand for expiration of time out to pay \nand expiration of time out to ack, respectively. You will notice\nthat the rules (included in the *rules.h* file) are slightly\ndifferent in comparison with the rules of the previous\nmodel.\n\n",
                "type": "Text_excerpt",
                "original_header": "Epromela model of the contract example",
                "parent_header": [
                    "2. Contraval (smart contract validation)"
                ]
            },
            "confidence": 1,
            "technique": "header_analysis",
            "source": "https://raw.githubusercontent.com/carlos-molina/contraval/master/README.md"
        },
        {
            "result": {
                "value": "The execution model of operations shown above is not unique. Another\naltrnative is shoen in the figure.\n\nAs an example, let us assume the execution model shown in the\nfollowing figure.\n\n<p align=\"center\">\n  <img src=\"./figures/executionmodelTOtoInitiate.png\" width=\"550\" title=\"Execution model that initiates or times out\">\n</p>\n\nOn the basis of this execution model, we can\nrepresent the contract example schematically\nin the following manner.\n\n<p align=\"center\">\n  <img src=\"./figures/helloWorldSmartContractBuyerStoreInitiateTO.png\" width=\"550\" title=\"Hello world contract: buyer-store with init TO\">\n</p>\n\nIn the figure, *pay*  represents the execution\nof the *pay*  operation initiated by the buyer.\nSimilarly, *ack* represens the execution of the\n*ack* operation initiated by the store.\nThese executions, result in the generation of\nbusiness events that are notified to the\nsmart contract (see below), for example, the\nexecution of the operation *pay* generates the\n*pay* business event.\nA diamon represents an alternative execution \nsplit, *O* stands for obligation and *TO* \nstands for Time Out. In this model (there\nare other alternatives), the\nbox at the right side of a diamon represents\nthe sucessful execution of the operation,\nwhile the *TO* represents the expiration of the\ndeadline to succssfully execute the operation.\n\nThe dashed lines represent abnormal paths to contract \ncompletion. They results from failures to meet\ndeadlines.\n\n\nThe epromela model includes four rules and is shown in\nthe figure. Observe that the model includes two separate\nrules (for for the normal outcome and another for\nthe timed out outcome) for handling each business \noperation. For instance, there is a rule for handling\n*pay* and another one independent rule for handling\n*payto*.\n\n<p align=\"center\">\n  <img src=\"./figures/epromelaModelOfBuyerStoreContractInitTO.png\" \n   width=\"400\" title=\"epromela model of the buyer-store example with\n                      init  TO.\">\n</p>\n\n\n\nMotivated readers are welcome to run this alternative\nmodel of the  hello world contract example,\nthey can find the complete code (and instructions to run it)\nat the [example/helloWorldSmartContract](https://github.com/carlos-molina/contraval/tree/master/examples/helloWorldSmartContractInitOrTO) \nfolder.\nAs in the model discussed earlier, a run of this\nmodel will mechanically produce all (three) the execution\nsequences encoded in the model, namely:\n\n```\n- payto\n- pay -> ack\n- pay -> ackto\n```\nWhere *payto* and *ackto* stand for expiration of time out to pay \nand expiration of time out to ack, respectively.\n\n\n",
                "type": "Text_excerpt",
                "original_header": "Alternative epromela model of the contract example",
                "parent_header": [
                    "2. Contraval (smart contract validation)"
                ]
            },
            "confidence": 1,
            "technique": "header_analysis",
            "source": "https://raw.githubusercontent.com/carlos-molina/contraval/master/README.md"
        }
    ],
    "faq": [
        {
            "result": {
                "value": "Smart contracts are impacted by several errors that\nwe clasified into design, implementation and mapping \nerrors.\n\n- **Design time errors:** They are accidently introduced \n  during the development phase by the humans responsible \n  for designing the smart contract.\n\n- **Implementation errors:** They are introduced by the\n  humans responsible for coding the smart contract,\n  for example, in Solidity language.\n\n- **Mapping errors:** They are introduced by the\n  humans responsible for mapping design into\n  implementation.\n\nThese types of errors are hard to avoid unless\na rigorous approach to validate the smart contract\nis taken. \n\n</br>\nIdeal smart contracts, that is, smart contracts that\nalways follow normal execution paths are relatively\nsimple to build and examine. However, realistic smart contracts\nare remarkably intricate. Complexity is due to\nfact that they are distributed systems executed\nby two or more parties interacting is a loosely\ncoupled manner over the conventional Internet. Consequently,\nat runtime, smart contracts are likely to be impacted\nby human, infrastructure (software, hardware and\nnetwork) and application behaviours:\n\n- Human behaviour: for example, the person responsible \n   for authorizing a payment might accidentaly or deliberately \n   delay it and make the smart contract fail. \n\n- Infrastructure behaviour: for example \n   unpredictable message delays, clock skews\n   and network breakdowns might delay a payment message\n   beyond its deadline. \n\n- Application behaviour: for example,  \n   the application might send a message incorrectly formatted, \n   include a delivery addresses\n   that cannot be found, take a delivery as\n   complete when the corresponding item has been delivered to the\n   wrong address, try charge a bank account that does not have\n   sufficient funds, and so on.\n   \n\nA smart contract that is meant to be reliable\nneeds to include mechanisms for\ntolerating these abnormal (and undesirable) situations \nthat will sooner or later materialize. \nThus the smart contract code that deals\nwith the normal (ideal) execution needs to be complemented with\ncode that deals with abnormal (exceptional)\nexecutions. That is, the smart contract need\nto be able to follow **plan B** (contingency)\nwhen **plan A** does not work.\n\n</br>\n\nAccounting for exceptional situation is a\nnecessary step towards building realiable\ncontracts, however, it is not enough. The \nproblem with bringing exceptions into the\ndesign of smart contracts is that they \nbecome populated by intricate executions that are\nhard to examine and reason about for\ncorrectness. The designer can address the\nproblem only with the assitance of mechanical \ntools that help in systematic validation \nof the smart contract. \n\n\n",
                "type": "Text_excerpt",
                "original_header": "Where do errors come from?",
                "parent_header": [
                    "1.- How to build reliable smart contracts",
                    "What can go wrong with a smart contract?"
                ]
            },
            "confidence": 1,
            "technique": "header_analysis",
            "source": "https://raw.githubusercontent.com/carlos-molina/contraval/master/README.md"
        }
    ],
    "installation": [
        {
            "result": {
                "value": "The directions for installation of epromela are documented in\nthe [UserGuide_v1.2.pdf](./UserGuide_v1.2.pdf) file. The document\nalso includes examples that demonstrate its operation. The reader\nis expected to have some basic knowledge of \n[SPIN and Promela](http://spinroot.com/spin/whatispin.html) and\na local computer to dowload and deploy them.\n",
                "type": "Text_excerpt",
                "original_header": "3. Installation"
            },
            "confidence": 1,
            "technique": "header_analysis",
            "source": "https://raw.githubusercontent.com/carlos-molina/contraval/master/README.md"
        },
        {
            "result": {
                "type": "Text_excerpt",
                "value": "\nIf you are a developer interested in building\nrealiable smart contracts, we suggest the following approach: \n",
                "original_header": "Smart contract models"
            },
            "confidence": 0.9838479201412775,
            "technique": "supervised_classification",
            "source": "https://raw.githubusercontent.com/carlos-molina/contraval/master/README.md"
        },
        {
            "result": {
                "type": "Text_excerpt",
                "value": "Feel free to email \n[carlos.molina + @ + cl.cam.a.uk](mailto:carlos.molina@cl.cam.ac.uk) \nif you have comments, bugs to report or questions. \n",
                "original_header": "6. Bug reporting and comments"
            },
            "confidence": 0.9758964656360553,
            "technique": "supervised_classification",
            "source": "https://raw.githubusercontent.com/carlos-molina/contraval/master/README.md"
        }
    ],
    "contributors": [
        {
            "result": {
                "value": "*  Abubkr A. Abdelsadiq developed the macros as part of his\n   PhD dissertation (2012) at University of Newcastle, UK.\n*  Ionnis Sfyrakis from University of Newcastle, UK\n   (Ioannis.Sfyrakis@newcastle.ac.uk) implemented \n   the Python parsers to extract execution sequences during his\n   Masters degree (2012) at Newcastle.\n*  [Carlos Molina-Jimenez](https://www.cl.cam.ac.uk/~cm770/ \"MyWebPage\")\n    from **The Department of\n    Computer Science and Technology (Computer Laboratory),\n    University of Cambridge** \n   (Carlos.Molina@cl.cam.ac.uk) implemented shell scripts to \n   mechanise the extraction of execution sequences. He has been\n   maintaining, documenting and testing the tool.\n   He is currently (2018) working in the \n   [TESCON project](https://www.cl.cam.ac.uk/~cm770/tescon/tescon.html \n   \"TESCON webpage\") (EPSRC grant Grant: RG90413 NRAG/536).\n\n\n",
                "type": "Text_excerpt",
                "original_header": "5. Contributors"
            },
            "confidence": 1,
            "technique": "header_analysis",
            "source": "https://raw.githubusercontent.com/carlos-molina/contraval/master/README.md"
        }
    ],
    "license": [
        {
            "result": {
                "value": "The contraval tool is released under the Apache License, \nVersion 2.0 which is available from Apache\u2019s web pages.\n \n",
                "type": "Text_excerpt",
                "original_header": "7. Licence"
            },
            "confidence": 1,
            "technique": "header_analysis",
            "source": "https://raw.githubusercontent.com/carlos-molina/contraval/master/README.md"
        }
    ],
    "full_title": [
        {
            "result": {
                "type": "String",
                "value": "1.- How to build reliable smart contracts"
            },
            "confidence": 1,
            "technique": "regular_expression",
            "source": "https://raw.githubusercontent.com/carlos-molina/contraval/master/README.md"
        }
    ],
    "images": [
        {
            "result": {
                "type": "Url",
                "value": "https://raw.githubusercontent.com/carlos-molina/contraval/master/./figures/developmentOfReliableSmartContracts.png"
            },
            "confidence": 1,
            "technique": "regular_expression",
            "source": "https://raw.githubusercontent.com/carlos-molina/contraval/master/README.md"
        },
        {
            "result": {
                "type": "Url",
                "value": "https://raw.githubusercontent.com/carlos-molina/contraval/master/./figures/executionmodelTOtoComplete.png"
            },
            "confidence": 1,
            "technique": "regular_expression",
            "source": "https://raw.githubusercontent.com/carlos-molina/contraval/master/README.md"
        },
        {
            "result": {
                "type": "Url",
                "value": "https://raw.githubusercontent.com/carlos-molina/contraval/master/./figures/helloWorldSmartContractBuyerStoreExecTO.png"
            },
            "confidence": 1,
            "technique": "regular_expression",
            "source": "https://raw.githubusercontent.com/carlos-molina/contraval/master/README.md"
        },
        {
            "result": {
                "type": "Url",
                "value": "https://raw.githubusercontent.com/carlos-molina/contraval/master/./figures/executionModelBilateralOperationsWithoutFailures.png"
            },
            "confidence": 1,
            "technique": "regular_expression",
            "source": "https://raw.githubusercontent.com/carlos-molina/contraval/master/README.md"
        },
        {
            "result": {
                "type": "Url",
                "value": "https://raw.githubusercontent.com/carlos-molina/contraval/master/./figures/executionModelBilateralOperationsWithoutFailuresBEG.png"
            },
            "confidence": 1,
            "technique": "regular_expression",
            "source": "https://raw.githubusercontent.com/carlos-molina/contraval/master/README.md"
        },
        {
            "result": {
                "type": "Url",
                "value": "https://raw.githubusercontent.com/carlos-molina/contraval/master/./figures/epromelaModelOfBuyerStoreContractOutputTO.png"
            },
            "confidence": 1,
            "technique": "regular_expression",
            "source": "https://raw.githubusercontent.com/carlos-molina/contraval/master/README.md"
        },
        {
            "result": {
                "type": "Url",
                "value": "https://raw.githubusercontent.com/carlos-molina/contraval/master/./figures/executionmodelTOtoInitiate.png"
            },
            "confidence": 1,
            "technique": "regular_expression",
            "source": "https://raw.githubusercontent.com/carlos-molina/contraval/master/README.md"
        },
        {
            "result": {
                "type": "Url",
                "value": "https://raw.githubusercontent.com/carlos-molina/contraval/master/./figures/helloWorldSmartContractBuyerStoreInitiateTO.png"
            },
            "confidence": 1,
            "technique": "regular_expression",
            "source": "https://raw.githubusercontent.com/carlos-molina/contraval/master/README.md"
        },
        {
            "result": {
                "type": "Url",
                "value": "https://raw.githubusercontent.com/carlos-molina/contraval/master/./figures/epromelaModelOfBuyerStoreContractInitTO.png"
            },
            "confidence": 1,
            "technique": "regular_expression",
            "source": "https://raw.githubusercontent.com/carlos-molina/contraval/master/README.md"
        },
        {
            "result": {
                "type": "Url",
                "value": "https://raw.githubusercontent.com/carlos-molina/contraval/master/./figures/executionModelOfBilateralOperationsWithFailures.png"
            },
            "confidence": 1,
            "technique": "regular_expression",
            "source": "https://raw.githubusercontent.com/carlos-molina/contraval/master/README.md"
        },
        {
            "result": {
                "type": "Url",
                "value": "https://raw.githubusercontent.com/carlos-molina/contraval/master/./figures/executionModelOfBilateralOperationsWithFailuresBEG.png"
            },
            "confidence": 1,
            "technique": "regular_expression",
            "source": "https://raw.githubusercontent.com/carlos-molina/contraval/master/README.md"
        }
    ],
    "related_papers": [
        {
            "result": {
                "type": "Url",
                "value": "https://arxiv.org/pdf/1808.00093.pdf \"implementation paper\""
            },
            "confidence": 1,
            "technique": "regular_expression",
            "source": "https://raw.githubusercontent.com/carlos-molina/contraval/master/README.md"
        }
    ]
}