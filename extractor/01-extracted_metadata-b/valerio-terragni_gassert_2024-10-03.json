{
    "somef_provenance": {
        "somef_version": "0.9.5",
        "somef_schema_version": "1.0.0",
        "date": "2024-10-03 21:06:38"
    },
    "code_repository": [
        {
            "result": {
                "value": "https://github.com/valerio-terragni/gassert",
                "type": "Url"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "owner": [
        {
            "result": {
                "value": "valerio-terragni",
                "type": "User"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "date_created": [
        {
            "result": {
                "value": "2020-11-15T21:34:55Z",
                "type": "Date"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "date_updated": [
        {
            "result": {
                "value": "2024-06-18T14:43:27Z",
                "type": "Date"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "description": [
        {
            "result": {
                "value": "GAssert: A Fully Automated Tool to Improve Assertion Oracles in Java Programs",
                "type": "String"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        },
        {
            "result": {
                "value": "GAssert is a tool for automatically improving assertion oracles in Java programs.\nAssertion oracles are executable boolean expression placed inside the program at a specific program point.\nA perfect assertion oracle should pass (return true) for all correct executions and fail (return false) for all incorrect executions. \n\nBecause designing perfect oracles is difficult, oracles may fail to distinguish between correct and incorrect executions. \nIn other words, they might have false positives (FP) and false negatives (FN).\nIntuitively, a FP is a correct state in which the assertion oracle incorrectly fails, while a FN is a incorrect state in which the assertion oracle incorrectly passes.\n\nGiven an assertion oracle and evidence of FPs and FNs, GAssert implements an evolutionary algorithm that explores the space of possible assertions to identify a new assertion with fewer FPs and FNs.\nGAssert relies on the tool [OASIs](https://github.com/guneljahan/OASIs) to gain evidence of FPs and FNs.\n               ",
                "type": "Text_excerpt",
                "original_header": "Artifact Description"
            },
            "confidence": 1,
            "technique": "header_analysis",
            "source": "https://raw.githubusercontent.com/valerio-terragni/gassert/main/README.md"
        },
        {
            "result": {
                "value": "The `./run_evaluation.sh` will run our 34 subjects for three oracle improvement approaches that we analysed (see our paper for more details):\n\n*\tGASSERT: the technique presented in this paper\n*  RANDOM: a random variant of oracle improvement\n*  DAIKON: daikon-based oracle improvement\n\n\nThe experiments will also repeat 10 times to cope with the stochasticity of the evolutionary-based and random-based approaches.\n\nAfter each experiments ends, the script will create a zip file under the folder `subject_results` with an appropriate name : `subjectName_methodName_assertionType_seedNumber.zip`.\nFor example, `StringUtils_stripToNull_daikon.assertions_GASSERT_4.zip` will contain the results of tool GASSERT, with the subject StringUtils, method stripToNull, starting from a daikon generated assertion, seed number four.\n\nAll subjects will run with daikon-generated invariants. Some of the subjects will run also with a human-written assertion (see RQ3). \nThe \"assertionType\" can be either \"daikon.assertions\" or \"human.assertions\" depending on whether the initial assertion was generated by Daikon (in RQ1, RQ2) or have been adopted from the previous study analysing human oracle improvement (in RQ3). The \"seed_num\" have values between 0 and 9, as we have re-run each approach 10 times to account for the stochastic nature of search-based.\n\n>**IMPORTANT**: For each subject, the initial sets of correct and incorrect states will be generated only once. All three tools will refer to the same initial sets.\n\nEach zip file contains the following subfolders:\n\t\n-\t**orig** - contains the Java source code of the subject class.\n-\t**evosuite-initial-tests** - contains initial  test cases generated by EvoSuite. These test cases were used to generated correct states for GAssert and Random.\n- **initial-mutations** - contains initial mutations generated by Major. This mutations along with the EvoSuite test cases were used to generate incorrect states for GAssert.\n- **input-assertions** - contains file \"daikon.assertions\" where Daikon-generated initial assertions are located. In case the subject was part of RQ3, where the comparison with human improvement was performed (i.e., SE1 SE2, SE3, SE4, SA3, SA4, SA3, SA4) the subfolder contains also file \"human.assertions\" with the initial assertions used in those experiments (if any).\n- **human-generated-assertions** - contains the assertions improved by humans (if any).\n- **randoop-evaluation-tests** - contains test cases generated by Randoop for the evaluation of the improved assertions.\n- **all-tests** - contains all tests used during the specific run, including OASIs generated ones\n- **output** - contains csv files with evaluation the results. The file \"info-iterations.csv\" reports results at each iteration. The file \"result-validation-init-output.csv\" reports results with initial set of Major mutations and EvoSuite test cases, while the file \"result-validation-output.csv\" reports results with validation test cases generated by Randoop and mutations generated by PIT.\n- **logs** - contains all the log files obtained during the experimental procedure.\n\nYou can find the already computed results of our experiments at [![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.3876638.svg)](https://doi.org/10.5281/zenodo.3876638)\n\n\n\n\n\n\n\n\n",
                "type": "Text_excerpt",
                "original_header": "Description of the evaluation results"
            },
            "confidence": 1,
            "technique": "header_analysis",
            "source": "https://raw.githubusercontent.com/valerio-terragni/gassert/main/README.md"
        }
    ],
    "name": [
        {
            "result": {
                "value": "gassert",
                "type": "String"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "full_name": [
        {
            "result": {
                "value": "valerio-terragni/gassert",
                "type": "String"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "issue_tracker": [
        {
            "result": {
                "value": "https://api.github.com/repos/valerio-terragni/gassert/issues",
                "type": "Url"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "forks_url": [
        {
            "result": {
                "value": "https://api.github.com/repos/valerio-terragni/gassert/forks",
                "type": "Url"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "stargazers_count": [
        {
            "result": {
                "value": 2,
                "type": "Number"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "keywords": [
        {
            "result": {
                "value": "",
                "type": "String"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "forks_count": [
        {
            "result": {
                "value": 0,
                "type": "Number"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "download_url": [
        {
            "result": {
                "value": "https://github.com/valerio-terragni/gassert/releases",
                "type": "Url"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "installation": [
        {
            "result": {
                "value": "![](https://valerio65.github.io/assets/img/gassert.png )\n<center>\n\nV. Terragni, G. Jahangirova, P. Tonella, M. Pezz\u00e8.  \nUniversit\u00e0 della Svizzera italiana (USI), Lugano, Switzerland \n</center>\n\n\n\n## Requirements\n\n* \t\tJDK 1.8\n* \t \tUnix or MAC OS X operating systems\n\n\n## Installation Instructions\n\nUnzip `GAssert.zip`, please maintain the same name of the root folder `GAssert` otherwise the bash scripts will not work. All the libraries required by GAssert are already included inside the zip. \n\nFirst you need to set the `JAVA_HOME` environmental variable.\nGo inside the `scripts` folder and open `init_environment.sh`.\nYou can set the `JAVA_HOME` at line 5.\n\nFor example: `    export JAVA_HOME=\"/Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home\"`\n\n> **We require JDK 1.8** because some of the libraries we used require JDK 1.8, we did not test the tool on newer/older JDKs. If you don't have JDK 1.8 installed on your computer, you can download it for free from here [https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html](https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html) \n\nThen, you need to instrument the JDK for [DAIKON](https://plse.cs.washington.edu/daikon/).\nFrom the command line change directory :\n\n\tcd libs/daikon-5.7.2/java\n\t\nbe sure that in the command line the variable `JAVA_HOME` is properly set. You can set the variable like you did in the script:\n\n\texport JAVA_HOME=\"/Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home\"\n\n\t\ninstrument the JDK like this\n\n\tmake dcomp_rt.jar\n\nafter few minutes you should see the following output\n\n\tProcessed 20500/20690 classes at Thu Jun 04 15:33:29 CEST 2020\n\tProcessed 20600/20690 classes at Thu Jun 04 15:33:30 CEST 2020\n\tFound 15635 statics\n\tWriting all classes to dcomp-rt/java/lang/jdk_classes.txt\n\tNo methods were skipped.\n\tdone at Thu Jun 04 15:33:32 CEST 2020\n\tjar cmf dcomp-rt/META-INF/MANIFEST.MF dcomp_rt.jar -C dcomp-rt .\n\nIf you have problem to compile [DAIKON](https://plse.cs.washington.edu/daikon/), please refer to the [troubleshooting of Daikon](https://plse.cs.washington.edu/daikon/download/doc/daikon.html#Troubleshooting)\n\n\n## Test Your Installation (basic usage example)\n\nTo test your installation, you can run GASSERT on one of our subjects. Go inside the scripts folder and invoke the script ` ./run_gassert.sh`. The scripts takes in input 4 parameters\n\n* TOOL (it can be either GASSERT, RANDOM or DAIKON)\n* subjectFolder (the folder name of the subject inside the subjects folder)\n* timeBudget (in minutes for the oracle improvement, a reasonable time budget is not less than 10 minutes)\n* fileNameAssertionInInput (the name of the file inside the subject's `input-assertions` folder)\n\nFor example:\n\n\t cd GAssert/scripts\n\t ./run_gassert.sh GASSERT simple-examples_getMin 10 human.assertions\n\nIt will run GASSERT for our running example (see Section 3.1 in the paper).\nMore specifically, it runs GASSERT for the subject `subjects\\simple-examples_getMin`, which refers to a method that returns the minimum between two integers.\nGASSERT will run with a time budget of 10 minutes and with the assertion in input found in the file `subjects\\simple-examples_getMin\\input-assertions\\human.assertions` (i.e., `assert(result > b)'). \n\nThe run will comprise of three phases: collection of the initial correct and incorrect states (PHASE 1), the oracle improvement process (PHASE 2), and the evaluation of the resulting assertion (PHASE 3).\n\n***\n### Phase 1 - collection of the initial correct and incorrect states\n\nNote that the time budget refers only to the evolutionary process, it excludes the time spent for Phase 1, which may take from 10 to 20 minutes.\nThis phase will use [Randoop](https://randoop.github.io/randoop/) to generate the validation tests and [Evosuite](https://github.com/EvoSuite/evosuite) to generate the initial tests.\nThe script executes the initial tests with a version of the method under test without the assertion, to collect a set of correct states.\nThen the initial tests will be executed on mutants generated by [Major](http://mutation-testing.org/downloads/) to collect the initial set of incorrect states. Finally, [DAIKON](https://plse.cs.washington.edu/daikon/) will generate an invariant for the assertion point, which can be used as an input of GAssert.\n\nWe now describe in details the behaviour of the script and the expected behaviour for Phase 1.\n\n\nIf the setup is correct, you should see the following output\n\n\tgenerating the initial sets of correct and incorrect states   \n\t- Use Randoop to generate Tests for class: SimpleMethods.java seed:    \n\tPUBLIC MEMBERS=7   \n\tExplorer = ForwardGenerator(allSequences:0, sideEffectFreeMethods:1119, subsumed_sequences:0, runtimePrimitivesSeen:38)\n\nThen Randoop will execute 10 times obtaining a maximum number of 1000 tests for the validation. You should find the generated tests inside `subjects\\simple-examples_getMin\\randoop-evaluation-tests`\n\nThen [Major](http://mutation-testing.org/downloads/) will generate a series of mutants for the method under test\n\n\t- Use Major to generate Mutants for class SimpleMethods.java\n\nYou should find the mutants of the method under tests in the folder `subjects\\simple-examples_getMin\\initial-mutations`\n\n\nThen [Evosuite](https://github.com/EvoSuite/evosuite) will run 10 times to generate additional tests\n\n\t- Use Evosuite to generate Tests for class: SimpleMethods.java LATEST VERSION\n\t* EvoSuite 1.0.6\n\t* Going to generate test cases for class: examples.SimpleMethods\n\t* Starting client\n\t* Connecting to master process on port 9922\n\t* Analyzing classpath: \n\n\nYou should find the initial Evosuite tests in `subjects\\simple-examples_getMin\\evosuite-initial-tests`\n\n\nThen you will see a series of gradle build failure/success. This is an expected behaviour because the script will run the generated tests on the mutants to collect the sets of incorrect states. Since the mutations might lead to failures, seeing build failures is normal.\n\n\n\t* Try:\n\tRun with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.\n\tBUILD FAILED in 1s\n\t3 actionable tasks: 3 executed\n\tfailing tests in file\n\t[examples.SimpleMethodsInit_1_ESTest.test01, examples.SimpleMethodsInit_1_ESTest.test02, \texamples.SimpleMethodsInit_1_ESTest.test03]\n\t:compileJava\n\t:processResources NO-SOURCE\n\t:classes\n\t:compileTestJava\n\t:processTestResources NO-SOURCE\n\t:testClasses\n\t:test\n\tResults: SUCCESS (3 tests, 3 successes, 0 failures, 0 skipped)\n\nAfter [DAIKON](https://plse.cs.washington.edu/daikon/) will generate an invariant for the method under test. You can find the invariant in the file `subjects\\simple-examples_getMin\\initial-assertions\\daikon.assertions`\n\n\tRUN DAIKON\n\tDaikon version 5.7.2, released November 7, 2018; http://plse.cs.washington.edu/daikon.\n\tReading declaration files Processing trace data; reading 1 dtrace file:\n\t============================================\n\texamples.RunAllTests.main(java.lang.String[]):::ENTER\n\targs != null\n\targs.getClass().getName() == java.lang.String[].class.getName()\n\t(\"oneOf.java.jpp: SEQUENCE unimplemented\" != null)\n\tdaikon.Quant.pairwiseEqual(daikon.Quant.collectObject(args, \"toString()\"), new String[] {  })\n\t=================================================\n\texamples.RunAllTests.main(java.lang.String[]):::EXIT\n\nThen Phase 1 terminates, the collected program states are stored on the disk inside the folder `initial-states` inside the subject folder.\n\n***\n### Phase 2 - Oracle improvement process\n\nNow the actual oracle improvement process will start. The time budget will be divided in 3 to allow for at least 2 iterations with the oracle assessor (see paper for the details).\n\nYou should see the following output at console:\n\n\ttime budget minutes single evo:  3\n\t START TOOL: GASSERT SEED: 0 BUDGET: 10  class: examples.SimpleMethods methodName: \n\t- Use Randoop to generate Tests for class: SimpleMethods.java seed: \n\nRandoop will start again to allow dynamic analysis which is needed for preparing the subject.\n\nThen, the evolutionary process will start by collecting the states and variables:\n\n\t2020-06-03 17:06:48,329 .<init>(EvolutionaryAlgorithm.java:56)     \n\t START GASSERT \n \n\t2020-06-03 17:06:48,429 .logInfo(TestExecutionStates.java:155)     \n\t number of tests |T|= ... \n\t \n\t2020-06-03 17:06:48,429 .logInfo(TestExecutionStates.java:156)     \n\t number of mutants |M|= ... \n\t \n\t2020-06-03 17:06:48,429 .logInfo(TestExecutionStates.java:159)     \n\t number of mutant tests |M||T|= .. \n\t \n\tsize correct states ... size incorrect states..\n\t2020-06-03 17:06:48,432 .load(VariableManager.java:60)     \n\t boolean variables that will be considered 0 [] \n\t \n\t2020-06-03 17:06:48,432 .load(VariableManager.java:61)     \n\t number variables that will be considered 5 [result, a, b, old_b, old_a] \n\t \n\t2020-06-03 17:06:48,433 .run(EvolutionaryAlgorithm.java:70)     \n\t start initialization population \n\t \n\tinitial assertions [result < a]\n\nThen you will see a summary for every 10 generations, showing the fittest solution. That is, the assertion with the lowest number of FP, FN, and lowest complexity. For example,\n\n\t# generation:              10\n\ttime cost:                 00:00:03.689\n\taverage time cost:         00:00:00.368\n\tAssertionManager cached assertions:          12659\n\tCPU load:                  3.7509765625\n\t# running threads:                  12\n\tMemory heap used:          408\n\tbest so far(((old_a > a) || (result <= old_b)) && ((result == (old_b * a)) || (result == old_a)))\n\t(((old_a > a) || (result <= old_b)) && ((result == (old_b * a)) || (result == old_a)))\n\tfitnessValueFP=0.0\n\tfitnessValueFN=0.09090909090909091\n\tcomplexity=17\n\ttype=BOOLEAN\n\tidsFNGOOD[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\tidsFPGOOD[0, 1, 2, 3, 4, 5]\n\nThis assertion has zero false positive but has 0.090 false negatives.\n\nIf GASSERT finds an assertion with zero FP and zero FN and it has executed for at least 100 generations, it will stop.\n\nThen it will start the iteration 1 and invoke the oracle assessor [OASIs](https://github.com/guneljahan/OASIs) for collecting evidence of false positives and false negatives\n\n\n\t============ ITERATION ========== 1\n\t...\n\trunning OASIS - FALSE NEGATIVE\n\t...\n\tFN? true\n\t...\n\trunning OASIS - FALSE POSITIVE\n\t...\n\tFP? true\n\nIf it finds evidence it will run again GASSERT to improve the assertion returned by the previous iteration. Now inside the `states` there will be the new correct and incorrect states produced by OASIs that will help GASSERT to converge to a better assertion.\n\nThis iterative process continues until the time budget expires or the oracle assessor OASIs cannot find any evidence of FP and FN.\n\nFor example, this can be the final assertion\n\n\tassert((((result == old_b) || (old_a == result)) && ((result <= old_a) && (result <= old_b)))); \n\n> Note that old_b refer to the values and the method entry, while b refers to the value at the assertion point\n> \n> \n\nPhase 2 is terminated. The outputted assertion will be saved inside `subjects\\simple-examples_getMin\\output\\output.assertions`. More information of the run can also be found in the folder `subjects\\simple-examples_getMin\\output\\`.\n\n***\n#### Phase 3 - evaluation of the resulting assertion\n\nThe final phase evaluates the final assertion with the mutation tool [PIT](https://pitest.org/) using the evaluation tests generated by Randoop during PHASE 1.\n\nYou should see PIT running\n\n\t================================================================================\n\t- Mutators\n\t================================================================================\n\t> org.pitest.mutationtest.engine.gregor.mutators.RemoveConditionalMutator_ORDER_ELSE\n\t>> Generated 3 Killed 1 (33%)\n\t> KILLED 1 SURVIVED 2 TIMED_OUT 0 NON_VIABLE 0 \n\t> MEMORY_ERROR 0 NOT_STARTED 0 STARTED 0 RUN_ERROR 0 \n\t> NO_COVERAGE 0 \n\t--------------------------------------------------------------------------------\n\t> org.pitest.mutationtest.engine.gregor.mutators.RemoveConditionalMutator_EQUAL_ELSE\n\t>> Generated 2 Killed 0 (0%)\n\t> KILLED 0 SURVIVED 2 TIMED_OUT 0 NON_VIABLE 0 \n\t> MEMORY_ERROR 0 NOT_STARTED 0 STARTED 0 RUN_ERROR 0 \n\t> NO_COVERAGE 0 \n\t--------------------------------------------------------------------------------\n\n\nat the end you will see the mutation score of the final assertion\n\n\ttotal mutation 4 killed mutation 3 ratio .75000000000000000000\n\tassert((((old_a >= b) || (old_a == result)) && ((old_b > old_a) || (result == old_b))));\n\nYou can see information about the mutations killed/survived inside the `subjects/simple-examples_getMin/build/reports/pitest`.\n\n\nPhase 3 is terminated. You can see more information about the result and the GASSERT run inside the `output` folder.\n\n\n## Run with the other subjects\n\nThere are a total of 34 subjects that we used in our experiment. This is the complete list\n\n\tAngle_diff  \n\tAngle_getTurn  \n\tArithmeticUtils_subAndCheck  \n\tAscii_equalsIgnoreCase  \n\tBooleanUtils_compare  \n\tBooleanUtils_toBoolean  \n\tComplex_reciprocal  \n\tConversion_hexDigitMsb0ToInt  \n\tConversion_hexToShort  \n\tEnvelope_maxExtent  \n\tFastMathNew_floor  \n\tIntMath_mod  \n\tLinearLocation_compareLocationValues  \n\tLongMath_saturatedMultiply  \n\tMathUtil_clamp  \n\tMathUtilsNew_copySignInt  \n\tQueueAr_dequeueAll  \n\tQueueAr_dequeue  \n\tQueueAr_enqueue  \n\tQueueAr_getFront  \n\tQueueAr_makeEmpty  \n\tStackAr_makeEmpty  \n\tStackAr_pop  \n\tStackAr_push  \n\tStackAr_topAndPop  \n\tStackAr_top  \n\tStringUtils_stripToNull  \n\tUnsignedInts_saturatedCast  \n\tUtf8_encodedLength  \n\tVector2D_crossProduct   \n\tsimple-examples_abs  \n\tsimple-examples_addElementToSet  \n\tsimple-examples_getMin  \n\tsimple-examples_incrementNumberAtIndex  \n\nFor example, if you want to run subject `BooleanUtils_compare`, using RANDOM approach and initial assertion the invariant generated by daikon, 90 minutes time budget you can run as follows\n\n\nFor example:\n\n\tcd GAssert/scripts\n\t./run_gassert.sh RANDOM BooleanUtils_compare 90 daikon.assertions\n\t\n## Prepare a new subject\n\nYou can prepare a new subject by following these instructions:\n\n1. create a folder and put inside the folder `subjects`\n2. be sure that it contains all the needed folders, to do so you can follow the provided template in `subjects/subjectName_methodName.zip`\n3. be sure that the name of the folder subject contains the method name after the underscore. For example, if the method under analysis is called `foo`, the subject folder must be called `subjectName_foo.zip`\n4. inside the subject folder must be the file `classname.input` with inside the fully qualified name of the class under test (e.g., `com.a.b.ClassA`).\n5. Inside the subject folder there must be a folder called `orig` which contain the source code of the class under test with the assertion point specified by an `assert(true);` statement. \n6. The assertion in input must be specified in a separate file located in the folder `input-assertions`\n7. If the initial assertion is in this form `assert(A && B && C);` please write the inner expression first one by one per line, and the second last line the entire assertion followed by an empty line. For example, if your assertion is `assert( (a>b) && (b!=0));` the file should contain the following:\n\t\n\t\n\t\tassert(a>b);  \n\t\tassert(b!=0);  \n\t\tassert((a>b) && (b!=0));  \n\t\n\n8. GAssert needs gradle to compile the subject. Please follow the provided template. You can add your own dependencies. Be sure that PIT is properly configured with the right package name (targetClasses)\n\n\t\tpitest {\n\t\t    targetClasses = ['examples.*']  \n\t\t    threads = 1\n\t\t    outputFormats = ['XML', 'HTML']\n\t\t    jvmArgs = ['-ea']\n\t\t    timestampedReports = false\n\t\t    mutators = [\"ALL\"]\n\t\t}\n\t\n\t\n\t\n\n\n\n\n",
                "type": "File_dump"
            },
            "confidence": 1,
            "technique": "file_exploration",
            "source": "https://raw.githubusercontent.com/valerio-terragni/gassert/main/INSTALL.md"
        },
        {
            "result": {
                "type": "Text_excerpt",
                "value": "\nTo reproduce the evaluation results you must first follow the installation instructions described in the file [INSTALL.md](INSTALL.md) \nAfter that, you can run the evaluation as follows: go to the main folder of GAssert artifact, then from the command line perform the following commands.\n```\n\tcd scripts\n\t./run_evaluation.sh\n```\n \n",
                "original_header": "How to reproduce the evaluation results"
            },
            "confidence": 0.98682239453205,
            "technique": "supervised_classification",
            "source": "https://raw.githubusercontent.com/valerio-terragni/gassert/main/README.md"
        }
    ],
    "readme_url": [
        {
            "result": {
                "value": "https://raw.githubusercontent.com/valerio-terragni/gassert/main/README.md",
                "type": "Url"
            },
            "confidence": 1,
            "technique": "file_exploration"
        }
    ],
    "type": [
        {
            "result": {
                "value": "commandline-application",
                "type": "String"
            },
            "confidence": 0.82,
            "technique": "software_type_heuristics"
        }
    ],
    "identifier": [
        {
            "result": {
                "type": "Url",
                "value": "https://doi.org/10.5281/zenodo.3877078"
            },
            "confidence": 1,
            "technique": "regular_expression",
            "source": "https://raw.githubusercontent.com/valerio-terragni/gassert/main/README.md"
        },
        {
            "result": {
                "type": "Url",
                "value": "https://doi.org/10.5281/zenodo.3876638"
            },
            "confidence": 1,
            "technique": "regular_expression",
            "source": "https://raw.githubusercontent.com/valerio-terragni/gassert/main/README.md"
        },
        {
            "result": {
                "type": "Url",
                "value": "https://doi.org/10.5281/zenodo.3876638"
            },
            "confidence": 1,
            "technique": "regular_expression",
            "source": "https://raw.githubusercontent.com/valerio-terragni/gassert/main/README.md"
        }
    ],
    "full_title": [
        {
            "result": {
                "type": "String",
                "value": ""
            },
            "confidence": 1,
            "technique": "regular_expression",
            "source": "https://raw.githubusercontent.com/valerio-terragni/gassert/main/README.md"
        }
    ],
    "logo": [
        {
            "result": {
                "type": "Url",
                "value": "https://valerio65.github.io/assets/img/gassert.png"
            },
            "confidence": 1,
            "technique": "regular_expression",
            "source": "https://raw.githubusercontent.com/valerio-terragni/gassert/main/README.md"
        }
    ]
}