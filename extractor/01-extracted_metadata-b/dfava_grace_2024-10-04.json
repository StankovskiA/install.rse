{
    "somef_provenance": {
        "somef_version": "0.9.5",
        "somef_schema_version": "1.0.0",
        "date": "2024-10-04 00:43:11"
    },
    "code_repository": [
        {
            "result": {
                "value": "https://github.com/dfava/grace",
                "type": "Url"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "owner": [
        {
            "result": {
                "value": "dfava",
                "type": "User"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "date_created": [
        {
            "result": {
                "value": "2020-01-09T12:25:15Z",
                "type": "Date"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "date_updated": [
        {
            "result": {
                "value": "2023-01-05T21:59:17Z",
                "type": "Date"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "license": [
        {
            "result": {
                "value": "https://api.github.com/licenses/bsd-3-clause",
                "type": "License",
                "name": "BSD 3-Clause \"New\" or \"Revised\" License",
                "url": "https://api.github.com/licenses/bsd-3-clause",
                "spdx_id": "BSD-3-Clause"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        },
        {
            "result": {
                "value": "Copyright (c) 2020, Daniel S. Fava. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n   * Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\n   * Neither the name of the copyright owner nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n",
                "type": "File_dump"
            },
            "confidence": 1,
            "technique": "file_exploration",
            "source": "https://raw.githubusercontent.com/dfava/grace/master/LICENSE"
        }
    ],
    "description": [
        {
            "result": {
                "value": "A race detector for Golang",
                "type": "String"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        },
        {
            "result": {
                "type": "Text_excerpt",
                "value": "Go ships with a [race detector](https://blog.golang.org/race-detector) built from the ThreadSanitizer library, [TSan](https://github.com/google/sanitizers) which employs the concept of vector-clocks (VCs).   We built Grace to study the trade-offs between VC-based race detection and HB-set based. \n",
                "original_header": "Grace"
            },
            "confidence": 0.9414414777854172,
            "technique": "supervised_classification",
            "source": "https://raw.githubusercontent.com/dfava/grace/master/README.md"
        },
        {
            "result": {
                "type": "Text_excerpt",
                "value": "Clocks are tracked in vectors.  A vector clock `V` as a function `V : Tid -> Nat`, meaning that `V(t)` is the value of the clock associated with a thread-id `t` according to the vector-clock `V`. \nEach thread `t` is given a vector clock, `C_t` where it keeps track of two things:\n1. `C_t(t)` records the current time at  `t`, and\n2. for another thread `u`, `C_t(u)` records the time of the most recent operation performed by `u` that is known to `t`.  In other words, `u`'s clock can advance without `t` knowing of it. The entry `C_t(u)` is the time of the most recent operation performed by `u` that `t` is aware of. \nRecall that, intuitively, a race is when a thread attempts to access a variable without the thread being \"aware\" of some previous access to that variable. So, when a thread `t` *attempts to write* to variable `z`, the thread must be aware of the previously occurring reads and writes to `z`. When a thread `t` *attempts to read* from `z`, the thread must be aware of the previous writes to `z` (since the are no read-read conflicts, there is no need for `t` to know of prior reads to `z`). \nAlthough we won't explore this in detail here, it's worth pointing out that the detector described in the previous paragraph can be improved.  As opposed to remembering writes to `z` in a vector clock `W_z`, a detector can remember only the clock and the thread identifier associated with the most recent write to `z`.  Similarly, the detector does not need to track all reads from `z` but only the reads that have accumulated after the most recent write.  This improvement over Djit lead to an algorithm known as [FastTrack](https://dl.acm.org/doi/abs/10.1145/1542476.1542490). \nThe last piece of the puzzle is how a thread's vector clock is updated.  Threads \"learn\" about each other's progress when they synchronize.  In the case of Go, synchronization is done via message passing.  In the case of locks, synchronization is done via `acquire` and `release` operations. \nEach lock `m` is associated with a vector clock `L_m`. When a thread `t` acquires `m`, the thread learns about about memory accesses performed by the thread who last released the lock.  More precisely, the vector clock of the thread, `C_t`, is updated to `C_t \u2294 L_m`.  When a thread `t` releases a lock `m`, the vector clock of the lock, `L_m`, is updated to `C_t` and thread's clock is advanced, meaning `C_t(t) := C_t(t)+1`. \n",
                "original_header": "Data-race detection based on vector clocks"
            },
            "confidence": 0.9276054146976417,
            "technique": "supervised_classification",
            "source": "https://raw.githubusercontent.com/dfava/grace/master/README.md"
        }
    ],
    "name": [
        {
            "result": {
                "value": "grace",
                "type": "String"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "full_name": [
        {
            "result": {
                "value": "dfava/grace",
                "type": "String"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "issue_tracker": [
        {
            "result": {
                "value": "https://api.github.com/repos/dfava/grace/issues",
                "type": "Url"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "forks_url": [
        {
            "result": {
                "value": "https://api.github.com/repos/dfava/grace/forks",
                "type": "Url"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "stargazers_count": [
        {
            "result": {
                "value": 12,
                "type": "Number"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "keywords": [
        {
            "result": {
                "value": "golang, python, race-detection, research-project",
                "type": "String"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "forks_count": [
        {
            "result": {
                "value": 1,
                "type": "Number"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "download_url": [
        {
            "result": {
                "value": "https://github.com/dfava/grace/releases",
                "type": "Url"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "programming_languages": [
        {
            "result": {
                "value": "Python",
                "name": "Python",
                "type": "Programming_language",
                "size": 30579
            },
            "confidence": 1,
            "technique": "GitHub_API"
        },
        {
            "result": {
                "value": "Go",
                "name": "Go",
                "type": "Programming_language",
                "size": 447
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "readme_url": [
        {
            "result": {
                "value": "https://raw.githubusercontent.com/dfava/grace/master/README.md",
                "type": "Url"
            },
            "confidence": 1,
            "technique": "file_exploration"
        }
    ],
    "type": [
        {
            "result": {
                "value": "commandline-application",
                "type": "String"
            },
            "confidence": 0.82,
            "technique": "software_type_heuristics"
        }
    ],
    "installation": [
        {
            "result": {
                "value": "In the happens-before set approach, a memory location keeps track of the most recent write onto that location, and of the most recent reads that accumulated after the write.  Technically, not all reads need to be recorded, only the most recent reads that are not ordered.  For example, if thread `t` reads from `z` and then reads again, the second read subsumes the first.  Similarly, a thread keeps track of the reads and writes to memory that it is \"aware of\".\n\nThe difference with vector-clocks is that we track individual accesses, which means that we consume more memory.  Vector-clock based race detectors have a worst-case memory consumption of `O(\u03c4)` per thread, where `\u03c4` is the number of entries in the vector, which is capped by the number of threads spawn during execution.  The per-thread memory consumption of happens-before sets is `O(\u03bd\u03c4)` where `\u03bd` is the number of shared variables in a program.\n\nVector clocks' memory efficiency, when compared to happens-before sets, come from VC's ability to succinctly capture the per-thread accesses that take place in between advances of a clock. A thread's clock is advanced when the thread releases a lock. All accesses made by a thread `t` in a given clock `c` are captured by the clock: if another thread `u` \"knows\" the value `c` of `t`'s clock, then `u` is in *happens-after* with all accesses made by `t`---that is, all accesses up to when `t`'s clock was advanced to `c + 1`. In contrast, the happens-before set representation is much more coarse. We keep track of individual accesses, as opposed to lumping them together into a clock number. This coarseness explains the extra factor of `\u03bd` in the worst-case analysis of the happens-before set solution. Although being a disadvantage in the worst case scenario, happens-before sets do provide some benefits.\n\nThe vector clocks associated with threads and locks grow monotonically. By growing monotonically we do not mean that time marches forward to increasing clock values. Instead, we mean that the number of clocks in a vector grows without provisions for the removal of entries. This growth can lead to the accumulation of \"stale\" information, where by stale we mean information that is not useful from the point of view of race detection. This growth stands in contrast to HB-set's approach to garbage collection. Stale information is purged from happens-before sets, which means they can shrink back to size zero after having grown in size.\n\n\nWe conjecture that an approach that purges stale information from VCs, similar to HB-set's notion of garbage collection, would be highly be beneficial.\n\n",
                "type": "Text_excerpt",
                "original_header": "Data-race detection based on happens-before sets",
                "parent_header": [
                    "Grace"
                ]
            },
            "confidence": 1,
            "technique": "header_analysis",
            "source": "https://raw.githubusercontent.com/dfava/grace/master/README.md"
        }
    ],
    "usage": [
        {
            "result": {
                "value": "Go ships with a race detector based on [TSan](https://github.com/google/sanitizers), which can be invoked with the `-race` command line flag:\n\n```\ngo run -race my_program.go\n```\n\nTo see what `-race` does, we can compile (but not link) a Go program and inspect the object file produced.  Take the `producer_consumers.go` file in `src/examples`:\n\n```\n$ go tool compile -race producer_consumers.go\n$ go tool objdump producer_consumers.o\n```\n\nThe first line above compiles the example and creates the file `producer_consumer.o`, the second line dumps the contents of the object file so we can read it.\nIf you search for the word `race` in the disassemble, you'll see many calls to things like `runtime.racefuncenter`, `runtime.racefuncexit`, `runtime.raceread` or `runtime.racewrite`.  These are calls into the race detector.  If you have the [Go sources](https://github.com/golang/go.git) available to follow along,  you can see that these functions are declared in `go/src/runtime/race.go`, but where/how are they implemented?  They are \"implemented\" in a platform specific way, inside the `race_amd64.s`, `race_arm64.s`, and `race_ppc64le.s` assembly files, depending on the architecture.  The word \"implementation\" is in quotes since the implementation is simply some thunk code that calls out to something else.  Here is the \"implementation\" of `raceread` which simply calls out to `__tsan_read` passing some arguments:\n\n```\n// func runtime\u00b7raceread(addr uintptr)\n// Called from instrumented code.\nTEXT  runtime\u00b7raceread(SB), NOSPLIT, $0-8\n  MOVD  addr+0(FP), R1\n  MOVD  LR, R2\n  // void __tsan_read(ThreadState *thr, void *addr, void *pc);\n  MOVD  $__tsan_read(SB), R9\n  JMP racecalladdr<>(SB)\n```\n\nThe actual implementation is in TSan, which ships with Go as a library.  The location of the TSan library is the following:\n\n```\n`go env GOTOOLDIR`/../../../src/runtime/race\n```\n\nGo ships with TSan in a `.syso` library file built for your OS and architecture.  For example, on Ubuntu we have:\n\n```\n$ cd `go env GOTOOLDIR`/../../../src/runtime/race\n$ pwd\n/usr/lib/go-1.10/src/runtime/race\n$ ls *.syso\nrace_linux_amd64.syso\n```\n\nwhile on Mac:\n\n```\n$ cd `go env GOTOOLDIR`/../../../src/runtime/race\n$ pwd\n/usr/local/Cellar/go/1.13.5/libexec/src/runtime/race\n$ ls *.syso\nrace_darwin_amd64.syso\n```\n\nWe can thus change the behavior of the race detector by checking out TSan from [sources](https://git.llvm.org/git/compiler-rt.git), modifying it, and replacing the `.syso` file ships by copying over our own `.syso`.  (On Ubuntu, Go can be installed as a [snap](https://en.wikipedia.org/wiki/Snappy_(package_manager)).  Modifying contents of a snap can be tricky.  Instead, I recommend installing Go with `apt` so it's easier for us to replace the race detector.)\n",
                "type": "Text_excerpt",
                "original_header": "TSan and Go",
                "parent_header": [
                    "Grace"
                ]
            },
            "confidence": 1,
            "technique": "header_analysis",
            "source": "https://raw.githubusercontent.com/dfava/grace/master/README.md"
        },
        {
            "result": {
                "value": "The modifications that we have done for Grace are simple: it mostly involves printing information about the calls to TSan to the console.  So, when a Go program is run with `-race`, we get lots of output.  We gather the output and feed it to the `t2g.py` script (short of Tsan-to-Grace), which converts this printed out text into calls to Grace.\n\nTo apply our patch to TSan, check TSan out from source, copy the diff file over and apply it:\n\n```\n$ git clone https://git.llvm.org/git/compiler-rt.git\n$ cd compiler-rt\n$ cd path_to_grace/src/tsan_patch.diff .\n$ git apply tsan_patch.diff\n\n```\n\nThe Go compiler lives in `compiler-rt/lib/tsan/go`, and can be built by running the `buildgo.sh` script.  Running the script will create a `.syso` file that should then be copied to the directory:\n\n```\n`go env GOTOOLDIR`/../../../src/runtime/race\n```\n\n",
                "type": "Text_excerpt",
                "original_header": "Applying patch to TSan",
                "parent_header": [
                    "Grace",
                    "TSan and Go"
                ]
            },
            "confidence": 1,
            "technique": "header_analysis",
            "source": "https://raw.githubusercontent.com/dfava/grace/master/README.md"
        },
        {
            "result": {
                "value": "When a Go program is compiled, channel operations (like sends and receives) translate to calls into the Go runtime.  Channels are implemented in `go/src/runtime/chan.go`.  When race detection is enabled with `-race`, a successful send onto a channel (function `chansend` in `chan.go`) yields three calls to TSan: first a call to `__tsan_readpc`, then a call to `__tsan_acquire`, and then `__tsan_release`.  The call to `__tsan_readpc` passes along a pointer to the `chansend` function in the runtime.  If you have [applied our patch to TSan](#Applying-patch-to-TSan), when you run with `-race` a Go program that uses channels, you will see text like this being printed:\n\n```\n__tsan_read_pc,0x000001383428,tid=5,0x00c42009a070,0x000000481c03,0x000000431741,chansend\n__tsan_read,0x000001393468,tid=6,0x0000004feb88,0x000000481cd9\n__tsan_acquire,0x000001383428,tid=5,0x00c42009a0d0\n__tsan_read_pc,0x000001393468,tid=6,0x00c42009a070,0x000000481cf3,0x000000431741,chansend\n__tsan_release,0x000001383428,tid=5,0x00c42009a0d0\n```\n\nThere is a bit to unpack here.  The first thing to notice is that these prints involve activities from two different threads: one with `tid=5` and another from `tid=6`.  Focusing on `tid=5`, the first is a call to `__tsan_read_pc` passing the address of `chansend` as an argument.  This line tells us that a send is starting.  The third and the last line are the lock acquisition and release protecting the entry in the channel's buffer where the message is placed.  Note that the fourth line is also a `chansend`, but from `tid=6`.  In other words, channel sends and receives from different threads can be interleaved.\n\nTSan works at the level of locks; channels are not a first-class concept.  Grace, on the other hand, works at the realm of channels, there are no locks.\nWe thus put the sequence of calls to TSan (`__tsan_readpc`, `__tsan_acquire`, and `__tsan_release`) back together and interpret them as a send operation on a particular channel.  Similarly, we can reinterpret calls to TSan related to the closing-of and receiving-from from a channel.\n\n",
                "type": "Text_excerpt",
                "original_header": "From `acquire` and `release` to `sends` and `receives`",
                "parent_header": [
                    "Grace",
                    "TSan and Go"
                ]
            },
            "confidence": 1,
            "technique": "header_analysis",
            "source": "https://raw.githubusercontent.com/dfava/grace/master/README.md"
        }
    ],
    "citation": [
        {
            "result": {
                "value": "```\n@InProceedings{fava.steffen:sbmf19,\n  author    = \"Daniel Fava and Martin Steffen\",\n  title     = \"Ready, set, {G}o! {D}ata-race detection and the {G}o language\",\n  booktitle = \"To appear in the pre-proceedings of the Brazilian Symposium on Formal Methods (SBMF)\",\n  year      = 2019,\n  note      = \"\\url{http://arxiv.org/abs/1910.12643} \",\n}\n```\n",
                "type": "Text_excerpt",
                "original_header": "Citing",
                "parent_header": [
                    "Grace"
                ]
            },
            "confidence": 1,
            "technique": "header_analysis",
            "source": "https://raw.githubusercontent.com/dfava/grace/master/README.md"
        },
        {
            "result": {
                "value": "@inproceedings{fava.steffen:sbmf19,\n    note = {\\url{http://arxiv.org/abs/1910.12643} },\n    year = {2019},\n    booktitle = {To appear in the pre-proceedings of the Brazilian Symposium on Formal Methods (SBMF)},\n    title = {Ready, set, {G}o! {D}ata-race detection and the {G}o language},\n    author = {Daniel Fava and Martin Steffen},\n}",
                "type": "Text_excerpt",
                "format": "bibtex",
                "title": "Ready, set, {G}o! {D}ata-race detection and the {G}o language",
                "author": "Daniel Fava and Martin Steffen"
            },
            "confidence": 1,
            "technique": "regular_expression",
            "source": "https://raw.githubusercontent.com/dfava/grace/master/README.md"
        }
    ],
    "full_title": [
        {
            "result": {
                "type": "String",
                "value": "Grace"
            },
            "confidence": 1,
            "technique": "regular_expression",
            "source": "https://raw.githubusercontent.com/dfava/grace/master/README.md"
        }
    ],
    "related_papers": [
        {
            "result": {
                "type": "Url",
                "value": "https://arxiv.org/abs/1910.12643"
            },
            "confidence": 1,
            "technique": "regular_expression",
            "source": "https://raw.githubusercontent.com/dfava/grace/master/README.md"
        }
    ]
}