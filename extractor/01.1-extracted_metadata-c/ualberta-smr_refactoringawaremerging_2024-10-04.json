{
    "somef_provenance": {
        "somef_version": "0.9.5",
        "somef_schema_version": "1.0.0",
        "date": "2024-10-04 18:45:58"
    },
    "code_repository": [
        {
            "result": {
                "value": "https://github.com/ualberta-smr/RefactoringAwareMergingEvaluation",
                "type": "Url"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "owner": [
        {
            "result": {
                "value": "ualberta-smr",
                "type": "Organization"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "date_created": [
        {
            "result": {
                "value": "2020-06-11T22:30:35Z",
                "type": "Date"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "date_updated": [
        {
            "result": {
                "value": "2023-01-04T17:30:21Z",
                "type": "Date"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "license": [
        {
            "result": {
                "value": "https://api.github.com/licenses/gpl-3.0",
                "type": "License",
                "name": "GNU General Public License v3.0",
                "url": "https://api.github.com/licenses/gpl-3.0",
                "spdx_id": "GPL-3.0"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "description": [
        {
            "result": {
                "value": "Refactoring-aware operation-based merging",
                "type": "String"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        },
        {
            "result": {
                "type": "Text_excerpt",
                "value": "In RefactoringAwareMergingEvaluation, we perform a quantitative comparison between operation-based refactoring-aware merging (implemented in RefMerge) and \ngraph-based refactoring-aware merging (implemented in IntelliMerge). Afterwards, we dive deeper into the results by manually sampling 50 merge scenarios and \ninvestigate the conflicts that Git, RefMerge, and IntelliMerge report as well as what their causes are. This evaluation was used in the paper, \"Refactoring-aware Operation-based Merging: An Empirical Evaluation\" (http://arxiv.org/abs/2112.10370).\n \n",
                "original_header": "RefactoringAwareMergingEvaluation"
            },
            "confidence": 0.9502460879835287,
            "technique": "supervised_classification",
            "source": "https://raw.githubusercontent.com/ualberta-smr/refactoringawaremerging/master/README.md"
        },
        {
            "result": {
                "type": "Text_excerpt",
                "value": "We implemented operation-based rerfactoring-aware merging in [RefMerge](https://github.com/ualberta-smr/RefMerge). RefMerge works by undoing refactorings, merging, and then replaying the refactorings. When merging, RefMerge considers the interactions between each pair of refactorings and how these interactions can lead to a conflict or how they can result in a dependence relationship. We provide the conflict and dependence detection logic for each pair in the [conflict detection wiki](https://github.com/ualberta-smr/RefMerge/wiki/Conflict-&-Dependence-Logic). \n \n",
                "original_header": "RefMerge"
            },
            "confidence": 0.9660587057749346,
            "technique": "supervised_classification",
            "source": "https://raw.githubusercontent.com/ualberta-smr/refactoringawaremerging/master/README.md"
        },
        {
            "result": {
                "type": "Text_excerpt",
                "value": "This project comes with the versions of IntelliMerge and RefMerge used in the paper. The source code for \nthe version of IntelliMerge we used is the same as that in our IntelliMerge replication.\n If you would like to use a different version of IntelliMerge, build the respective IntelliMerge version \nand copy and paste that version into the lib folder. \n",
                "original_header": "Using IntelliMerge and RefMerge"
            },
            "confidence": 0.9899278200090313,
            "technique": "supervised_classification",
            "source": "https://raw.githubusercontent.com/ualberta-smr/refactoringawaremerging/master/README.md"
        },
        {
            "result": {
                "type": "Text_excerpt",
                "value": "A list of merge scenarios and their corresponding projects that we used in RQ2 is stored in `experiment_data/rq2_scenarios`.\n \n",
                "original_header": "RQ2 data"
            },
            "confidence": 0.9591132935565636,
            "technique": "supervised_classification",
            "source": "https://raw.githubusercontent.com/ualberta-smr/refactoringawaremerging/master/README.md"
        }
    ],
    "name": [
        {
            "result": {
                "value": "RefactoringAwareMergingEvaluation",
                "type": "String"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "full_name": [
        {
            "result": {
                "value": "ualberta-smr/RefactoringAwareMergingEvaluation",
                "type": "String"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "issue_tracker": [
        {
            "result": {
                "value": "https://api.github.com/repos/ualberta-smr/RefactoringAwareMergingEvaluation/issues",
                "type": "Url"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "forks_url": [
        {
            "result": {
                "value": "https://api.github.com/repos/ualberta-smr/RefactoringAwareMergingEvaluation/forks",
                "type": "Url"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "stargazers_count": [
        {
            "result": {
                "value": 2,
                "type": "Number"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "keywords": [
        {
            "result": {
                "value": "",
                "type": "String"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "forks_count": [
        {
            "result": {
                "value": 0,
                "type": "Number"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "download_url": [
        {
            "result": {
                "value": "https://github.com/ualberta-smr/refactoringawaremerging/releases",
                "type": "Url"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "programming_languages": [
        {
            "result": {
                "value": "Java",
                "name": "Java",
                "type": "Programming_language",
                "size": 770192
            },
            "confidence": 1,
            "technique": "GitHub_API"
        },
        {
            "result": {
                "value": "Python",
                "name": "Python",
                "type": "Programming_language",
                "size": 179067
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "readme_url": [
        {
            "result": {
                "value": "https://raw.githubusercontent.com/ualberta-smr/refactoringawaremerging/master/README.md",
                "type": "Url"
            },
            "confidence": 1,
            "technique": "file_exploration"
        }
    ],
    "requirements": [
        {
            "result": {
                "value": "* Linux\n* git\n* Java 11\n* IntelliJ (Community Addition) Version 2020.1.2\n",
                "type": "Text_excerpt",
                "original_header": "System requirements",
                "parent_header": [
                    "RefactoringAwareMergingEvaluation"
                ]
            },
            "confidence": 1,
            "technique": "header_analysis",
            "source": "https://raw.githubusercontent.com/ualberta-smr/refactoringawaremerging/master/README.md"
        }
    ],
    "run": [
        {
            "result": {
                "value": "Use `Git Clone https://github.com/tsantalis/RefactoringMiner.git` to clone RefactoringMiner. \nThen build RefactoringMiner with `./gradlew distzip`. It will be under build/distributions.\n",
                "type": "Text_excerpt",
                "original_header": "1. Clone and build RefactoringMiner",
                "parent_header": [
                    "RefactoringAwareMergingEvaluation",
                    "How to run"
                ]
            },
            "confidence": 1,
            "technique": "header_analysis",
            "source": "https://raw.githubusercontent.com/ualberta-smr/refactoringawaremerging/master/README.md"
        },
        {
            "result": {
                "value": "You will need to add RefactoringMiner to your local maven repository to\nuse it in the build.gradle. You can use `mvn install:install-file -Dfile=<path-to-file>`\nto add it to your local maven repository. You can verify that it's been installed \nby checking the path `/home/username/.m2/repository/org/refactoringminer`.\n",
                "type": "Text_excerpt",
                "original_header": "2. Add RefactoringMiner to your local maven repository",
                "parent_header": [
                    "RefactoringAwareMergingEvaluation",
                    "How to run"
                ]
            },
            "confidence": 1,
            "technique": "header_analysis",
            "source": "https://raw.githubusercontent.com/ualberta-smr/refactoringawaremerging/master/README.md"
        },
        {
            "result": {
                "value": "Use the refactoring analysis dump found [here](https://github.com/ualberta-smr/refactoring-analysis-results)\nto populate the original_analysis database. We use the original_analysis database to collect the 10 additional projects that we evaluate on.\nUse the `database/intelliMerge_data1`\nsql dump to populate intelliMerge_data1 database. This database contains the projects and merge scenarios used in IntelliMerge's evaluation.\nUse the database/refactoringAwareMerging_dataset to populate refactoringAwareMerging_dataset database. A description of how to populate the databases can be found \n[here](https://github.com/ualberta-smr/RefactoringAwareMergingEvaluation/wiki/Datasets).\n",
                "type": "Text_excerpt",
                "original_header": "3. Populate databases",
                "parent_header": [
                    "RefactoringAwareMergingEvaluation",
                    "How to run"
                ]
            },
            "confidence": 1,
            "technique": "header_analysis",
            "source": "https://raw.githubusercontent.com/ualberta-smr/refactoringawaremerging/master/README.md"
        },
        {
            "result": {
                "value": "To replicate RQ1, first run `python project_sampler` to get the additional 10 projects used \nin the evaluation. Then, run `python refMerge_data_resolver` to get the commits with\nrefactoring-related conflicts.\n\nPut the `stats/refMerge_evaluation_commits` file generated by `refMerge_data_resolver` in the resources folder. While running the evaluation, you have to manually load each project but after that the evaluation is automated. For each project, you will need to do the following:\n\n1. Add the corresponding evaluation project to the configuration in the IntelliJ IDE under `Run | Edit Configurations`. For example, `-PevaluationProject=error-prone`. \n\n2. Clone the corresponding evaluation project.\n\n3. Open the evaluation project with the IntelliJ IDEA in a new window. \n\n4. Wait for IntelliJ to build the cloned project, then close it.\n\n5. Run the evaluation for the project by clicking the `Run` button in the IntelliJ IDE.\n\n6. Wait for the evaluation pipeline to finish processing that project.\n\nThe data from the evaluation pipeline will be stored in the database, `refMerge_evaluation`. The evaluation pipeline will create the database if it does not already exist. Finally, use the scripts in evaluation_data_plotter to get tables and plots from the data.\n\n",
                "type": "Text_excerpt",
                "original_header": "Running RQ1 experiment",
                "parent_header": [
                    "RefactoringAwareMergingEvaluation",
                    "RefactoringAwareMerging Comparison"
                ]
            },
            "confidence": 1,
            "technique": "header_analysis",
            "source": "https://raw.githubusercontent.com/ualberta-smr/refactoringawaremerging/master/README.md"
        },
        {
            "result": {
                "value": "First, use  the file `stats/evaluation_data_resolver` by running the command `python evaluation_data_resolver` to get the list of merge commit ids to sample. This will always result in the same merge scenarios when given the same data.\nThis experiment is a manual analysis and we manually re-run the merge for each merge scenario. These are the steps that we follow for each merge scenario:\n\n1. Query the results in RQ1 using `SELECT * FROM merge_commit WHERE id = x` where x is the merge commit ID. Use this query to get the parent commits.\n\n2. Use `git merge-base p1 p2` in the corresponding project to get the base commit where p1 is the left parent commit and p2 is the right parent commit.\n\n3. Use `SELECT distinct path FROM conflict WHERE merge_commit_id = x;` to get a list of the conflicting file paths.\n\n4. Compare each conflicting region with the corresponding region in the base, left, and right commits.\n\n5. Record if the region should be a merge conflict or not based on the base, left, and right commits. \n\n6. Record if the conflict reported by the merge tool is a true positive or false positive based on the previous step. Record why you think so.\n\n7. Investigate the same region in the other merge tools and record what you find. \n\n8. Record any additional notes about the discrepancies you find, such as the reasons for the discrepancies. \n\n",
                "type": "Text_excerpt",
                "original_header": "Running RQ2 experiment",
                "parent_header": [
                    "RefactoringAwareMergingEvaluation",
                    "RefactoringAwareMerging Comparison"
                ]
            },
            "confidence": 1,
            "technique": "header_analysis",
            "source": "https://raw.githubusercontent.com/ualberta-smr/refactoringawaremerging/master/README.md"
        }
    ],
    "usage": [
        {
            "result": {
                "value": "Run `python intelliMerge_data_resolver` to get the IntelliMerge commits used in\nthe IntelliMerge replication. \n",
                "type": "Text_excerpt",
                "original_header": "Get IntelliMerge replication commits",
                "parent_header": [
                    "RefactoringAwareMergingEvaluation",
                    "IntelliMerge Replication"
                ]
            },
            "confidence": 1,
            "technique": "header_analysis",
            "source": "https://raw.githubusercontent.com/ualberta-smr/refactoringawaremerging/master/README.md"
        }
    ],
    "installation": [
        {
            "result": {
                "type": "Text_excerpt",
                "value": "This project comes with the version of IntelliMerge that we used to run the IntelliMerge replication, \nfound in our fork of IntelliMerge, https://github.com/max-ellis/IntelliMerge.git, at commit `5966f75`.\n \n",
                "original_header": "Using IntelliMerge"
            },
            "confidence": 0.9998914615308505,
            "technique": "supervised_classification",
            "source": "https://raw.githubusercontent.com/ualberta-smr/refactoringawaremerging/master/README.md"
        },
        {
            "result": {
                "type": "Text_excerpt",
                "value": "Edit the configuration tasks to have `:runIde -Pmode=comparison -PdataPath=path \n-PevaluationProject=project`, where path is the path to the cloned test projects\nand project is the test project.\n \n",
                "original_header": "Edit configuration"
            },
            "confidence": 0.9986477002553387,
            "technique": "supervised_classification",
            "source": "https://raw.githubusercontent.com/ualberta-smr/refactoringawaremerging/master/README.md"
        },
        {
            "result": {
                "type": "Text_excerpt",
                "value": "This project comes with the versions of IntelliMerge and RefMerge used in the paper. The source code for \nthe version of IntelliMerge we used is the same as that in our IntelliMerge replication.\n If you would like to use a different version of IntelliMerge, build the respective IntelliMerge version \nand copy and paste that version into the lib folder. \nRefMerge's history can be found here: https://github.com/ualberta-smr/RefMerge.git. The\nversion used within this evaluation is release 1.0.0 in commit `adb13ff`.\nIf you would like to use a different version of\nRefMerge, you first need to clone RefMerge. After you clone RefMerge, copy the code in\n`ca.ualberta.cs.smr.refmerge` and replace the code in the `ca.ualberta.cs.smr.refmerge` package within this project (found [here](https://github.com/ualberta-smr/RefactoringAwareMergingEvaluation/tree/master/src/main/java/ca/ualberta/cs/smr/refmerge)). \n### Edit configuration\nEdit the configuration tasks in the IntelliJ IDE under `Run | Edit Configurations` (more information can be found [here](https://www.jetbrains.com/help/idea/run-debug-configuration.html#create-permanent)) to have `:runIde` and include set `-Pmode=` to `comparison`.\nThen, set `-PevaluationProject=` to the project that you want to evaluate on. For example,\nit would look like `-PevaluationProject=error-prone` if you want to evaluate on error-prone.\n \n",
                "original_header": "Using IntelliMerge and RefMerge"
            },
            "confidence": 0.9783246276577736,
            "technique": "supervised_classification",
            "source": "https://raw.githubusercontent.com/ualberta-smr/refactoringawaremerging/master/README.md"
        }
    ],
    "full_title": [
        {
            "result": {
                "type": "String",
                "value": "RefactoringAwareMergingEvaluation"
            },
            "confidence": 1,
            "technique": "regular_expression",
            "source": "https://raw.githubusercontent.com/ualberta-smr/refactoringawaremerging/master/README.md"
        }
    ],
    "documentation": [
        {
            "result": {
                "type": "Url",
                "value": "https://github.com/ualberta-smr/RefMerge/wiki/Conflict-&-Dependence-Logic",
                "format": "wiki"
            },
            "confidence": 1,
            "technique": "regular_expression",
            "source": "https://raw.githubusercontent.com/ualberta-smr/refactoringawaremerging/master/README.md"
        }
    ]
}