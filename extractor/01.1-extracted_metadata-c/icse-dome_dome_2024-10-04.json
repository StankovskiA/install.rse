{
    "somef_provenance": {
        "somef_version": "0.9.5",
        "somef_schema_version": "1.0.0",
        "date": "2024-10-04 20:05:58"
    },
    "code_repository": [
        {
            "result": {
                "value": "https://github.com/ICSE-DOME/DOME",
                "type": "Url"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "owner": [
        {
            "result": {
                "value": "ICSE-DOME",
                "type": "User"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "date_created": [
        {
            "result": {
                "value": "2023-02-14T13:33:02Z",
                "type": "Date"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "date_updated": [
        {
            "result": {
                "value": "2024-07-24T16:02:52Z",
                "type": "Date"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "description": [
        {
            "result": {
                "value": "Developer-Intent Driven Code Comment Generation",
                "type": "String"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        },
        {
            "result": {
                "value": "Existing automatic code comment generators mainly focus on producing a general description of functionality for a given code snippet without considering developer intentions. However, in real-world practice, comments are complicated, which often contain information reflecting various intentions of developers, e.g., functionality summarization, design rationale, implementation details, code properties, etc. To bridge the gap between automatic code comment generation and real-world comment practice, we define Developer-Intent Driven Code Comment Generation, which can generate intent-aware comments for the same source code with different intents. To tackle this challenging task, we propose DOME, an approach that utilizes Intent-guided Selective Attention to explicitly select intent-relevant information from the source code, and produces various comments reflecting different intents. Our approach is evaluated on two real-world Java datasets, and the experimental results show that our approach outperforms the state-of-the-art baselines. A human evaluation also confirms the significant potential of applying DOME in practical usage, enabling developers to comment code effectively according to their own needs.\n",
                "type": "Text_excerpt",
                "original_header": "1 Project Summary",
                "parent_header": [
                    "ICSE22_DOME"
                ]
            },
            "confidence": 1,
            "technique": "header_analysis",
            "source": "https://raw.githubusercontent.com/icse-dome/dome/master/README.md"
        },
        {
            "result": {
                "type": "Text_excerpt",
                "value": "This is a replication package for ICSE23 Paper `Developer-Intent Driven Code Comment Generation`.<br>\n \n",
                "original_header": "ICSE22_DOME"
            },
            "confidence": 0.9805296621792543,
            "technique": "supervised_classification",
            "source": "https://raw.githubusercontent.com/icse-dome/dome/master/README.md"
        }
    ],
    "name": [
        {
            "result": {
                "value": "DOME",
                "type": "String"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "full_name": [
        {
            "result": {
                "value": "ICSE-DOME/DOME",
                "type": "String"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "issue_tracker": [
        {
            "result": {
                "value": "https://api.github.com/repos/ICSE-DOME/DOME/issues",
                "type": "Url"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "forks_url": [
        {
            "result": {
                "value": "https://api.github.com/repos/ICSE-DOME/DOME/forks",
                "type": "Url"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "stargazers_count": [
        {
            "result": {
                "value": 15,
                "type": "Number"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "keywords": [
        {
            "result": {
                "value": "",
                "type": "String"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "forks_count": [
        {
            "result": {
                "value": 1,
                "type": "Number"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "download_url": [
        {
            "result": {
                "value": "https://github.com/icse-dome/dome/releases",
                "type": "Url"
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "programming_languages": [
        {
            "result": {
                "value": "Python",
                "name": "Python",
                "type": "Programming_language",
                "size": 125896
            },
            "confidence": 1,
            "technique": "GitHub_API"
        },
        {
            "result": {
                "value": "Jupyter Notebook",
                "name": "Jupyter Notebook",
                "type": "Programming_language",
                "size": 21009
            },
            "confidence": 1,
            "technique": "GitHub_API"
        }
    ],
    "readme_url": [
        {
            "result": {
                "value": "https://raw.githubusercontent.com/icse-dome/dome/master/README.md",
                "type": "Url"
            },
            "confidence": 1,
            "technique": "file_exploration"
        }
    ],
    "executable_example": [
        {
            "result": {
                "value": "https://raw.githubusercontent.com/icse-dome/dome/master/DOME_Application.ipynb",
                "type": "Url",
                "format": "jupyter_notebook"
            },
            "confidence": 1,
            "technique": "file_exploration",
            "source": "https://raw.githubusercontent.com/icse-dome/dome/master/DOME_Application.ipynb"
        },
        {
            "result": {
                "value": "https://raw.githubusercontent.com/icse-dome/dome/master/src/Application_Demo/.ipynb_checkpoints/DOME_Application-checkpoint.ipynb",
                "type": "Url",
                "format": "jupyter_notebook"
            },
            "confidence": 1,
            "technique": "file_exploration",
            "source": "https://raw.githubusercontent.com/icse-dome/dome/master/src/Application_Demo/.ipynb_checkpoints/DOME_Application-checkpoint.ipynb"
        },
        {
            "result": {
                "value": "https://raw.githubusercontent.com/icse-dome/dome/master/src/comment_generator/dataset/tlcodesum/.ipynb_checkpoints/statistics-checkpoint.ipynb",
                "type": "Url",
                "format": "jupyter_notebook"
            },
            "confidence": 1,
            "technique": "file_exploration",
            "source": "https://raw.githubusercontent.com/icse-dome/dome/master/src/comment_generator/dataset/tlcodesum/.ipynb_checkpoints/statistics-checkpoint.ipynb"
        },
        {
            "result": {
                "value": "https://raw.githubusercontent.com/icse-dome/dome/master/src/comment_generator/dataset/funcom/.ipynb_checkpoints/Untitled-checkpoint.ipynb",
                "type": "Url",
                "format": "jupyter_notebook"
            },
            "confidence": 1,
            "technique": "file_exploration",
            "source": "https://raw.githubusercontent.com/icse-dome/dome/master/src/comment_generator/dataset/funcom/.ipynb_checkpoints/Untitled-checkpoint.ipynb"
        }
    ],
    "requirements": [
        {
            "result": {
                "value": "* Hardwares: NVIDIA GeForce RTX 3060 GPU, intel core i5 CPU\n* OS: Ubuntu 20.04\n* Packages: \n  * python 3.9\n  * pytorch 1.9.0\n  * cuda 11.1\n  * transformers 4.9.2\n  * numpy\n  * tqdm\n",
                "type": "Text_excerpt",
                "original_header": "2.1 Requirements",
                "parent_header": [
                    "ICSE22_DOME",
                    "2 Get Started"
                ]
            },
            "confidence": 1,
            "technique": "header_analysis",
            "source": "https://raw.githubusercontent.com/icse-dome/dome/master/README.md"
        }
    ],
    "usage": [
        {
            "result": {
                "value": "*DOME* is evaluated on [Funcom](http://leclair.tech/data/funcom/) and [TLC](https://github.com/xing-hu/TL-CodeSum) benchmark datasets.<br>\n[Shi et al.](https://arxiv.org/pdf/2207.05579) have reported that many benchmark datasets have noisy data, e.g. *Verbose Sentence*, *Content Tampering*. So we directly use the \"clean\" version of the two datasets open sourced by them (https://github.com/BuiltOntheRock/FSE22_BuiltOntheRock).",
                "type": "Text_excerpt",
                "original_header": "2.2.1 benchmark datasets",
                "parent_header": [
                    "ICSE22_DOME",
                    "2 Get Started",
                    "2.2 Dataset"
                ]
            },
            "confidence": 1,
            "technique": "header_analysis",
            "source": "https://raw.githubusercontent.com/icse-dome/dome/master/README.md"
        },
        {
            "result": {
                "value": "Since training and evaluating *DOME* require a large volume of labeled comment-intent data, we develop a COmment-INtent labeling tool, named *COIN*, to support the automatic annotation of comment intents for the codecomment dataset. To train *COIN*, we randomly sample 20K code-comment pairs from Funcom and TLC (10K data for each), and invite five developers to manually classify the data into six intent categories. The manually labeled dataset can be found in ```src/comment_classifier/dataset/manually_labeled_data_20000.xlsx```.",
                "type": "Text_excerpt",
                "original_header": "2.2.2 manually labeled dataset",
                "parent_header": [
                    "ICSE22_DOME",
                    "2 Get Started",
                    "2.2 Dataset"
                ]
            },
            "confidence": 1,
            "technique": "header_analysis",
            "source": "https://raw.githubusercontent.com/icse-dome/dome/master/README.md"
        },
        {
            "result": {
                "value": "Then, we use the well-trained *COIN* to automatically annotate the comments in the two datasets with the corresponding intent categories. Since the others comments are seen as unspecified or ambiguous\ncomments, we exclude all data with the intent category of others. In common with [Rencos](https://github.com/zhangj111/rencos), we further remove the exactly duplicated code-comment pairs in the test set for TLC dataset. The preprocessed datasets can be downloaded at [DOME_Dataset](https://drive.google.com/file/d/1KBJysjgJ1i6UDB5O--44Z1YT9u-qCZiG/view?usp=sharing)\n\n",
                "type": "Text_excerpt",
                "original_header": "2.2.3 auto-labeled dataset",
                "parent_header": [
                    "ICSE22_DOME",
                    "2 Get Started",
                    "2.2 Dataset"
                ]
            },
            "confidence": 1,
            "technique": "header_analysis",
            "source": "https://raw.githubusercontent.com/icse-dome/dome/master/README.md"
        },
        {
            "result": {
                "value": "1. Download the pretrained CodeBERT model from [transformers](https://huggingface.co/microsoft/codebert-base) and put the model file into the ```src/comment_classifier/pretrained_codebert``` directory.\n\n2. Train the Comment-Intent Labeling Tool *COIN* model with intent-labeled dataset.\n```\npython src/comment_classifier/train.py\n```\n3. Use the well-trained *COIN* to annotate the two benchmark datasets automatically.\n```\npython src/comment_classifier/prediction.py\n```\n",
                "type": "Text_excerpt",
                "original_header": "2.3 Comment Intent Labeling Tool",
                "parent_header": [
                    "ICSE22_DOME",
                    "2 Get Started"
                ]
            },
            "confidence": 1,
            "technique": "header_analysis",
            "source": "https://raw.githubusercontent.com/icse-dome/dome/master/README.md"
        },
        {
            "result": {
                "value": "1. Go the ```src/comment_generator``` directory, download the preprocessed datasets and put them into the ```dataset``` directory, and generate the vocabulary:\n```\ncd src/comment_generator\npython ./dataset/{DATASET}/generate_vocab.py\n```\n2. Train *DOME* model:\n```\npython train_DOME.py\n```\n3. Test *DOME* model:\n```\npython prediction_DOME.py\n```\n",
                "type": "Text_excerpt",
                "original_header": "2.4 Developer-Intent Driven Comment Generator",
                "parent_header": [
                    "ICSE22_DOME",
                    "2 Get Started"
                ]
            },
            "confidence": 1,
            "technique": "header_analysis",
            "source": "https://raw.githubusercontent.com/icse-dome/dome/master/README.md"
        }
    ],
    "contributing_guidelines": [
        {
            "result": {
                "value": "```\n>>> classifier = commentClassifier('./comment_classifier/pretrained_codebert', 6, 0.2)\n>>> classifier.load_state_dict(torch.load(\"./comment_classifier/saved_model/comment_classifier.pkl\"))\n>>> classifier.cuda()\n\n>>> comment = 'Starts the background initialization'\n>>> tokenizer = AutoTokenizer.from_pretrained('./comment_classifier/pretrained_codebert')\n>>> logits = classifier(coin_preprocess(tokenizer, comment))\n>>> intent = class_name[int(torch.argmax(logits, 1))]\n>>> print('comment:', comment, '\\nintent:', intent)\ncomment: Starts the background initialization \nintent: what\n```",
                "type": "Text_excerpt",
                "original_header": "Using COIN to identify the developer-intent for a given comment",
                "parent_header": [
                    "ICSE22_DOME",
                    "3 Application"
                ]
            },
            "confidence": 1,
            "technique": "header_analysis",
            "source": "https://raw.githubusercontent.com/icse-dome/dome/master/README.md"
        },
        {
            "result": {
                "value": "```\n>>> generator = Generator(config.d_model, config.d_intent, config.d_ff, config.head_num, config.enc_layer_num, config.dec_layer_num, config.vocab_size, config.max_comment_len, config.clip_dist_code, config.eos_token, config.intent_num, config.stat_k, config.token_k, config.dropout, None)\n>>> generator.load_state_dict(torch.load(f\"./src/comment_generator/saved_model/tlcodesum/comment_generator.pkl\"))\n>>> generator.cuda()\n\n>>> for i in range(3):\n...    print(\"code:\\n\", raw_code[i])\n...    print(\"what:\", prediction(input_code[i], input_exemplar[i], 'what', code_valid_len[i]))\n...    print(\"why:\", prediction(input_code[i], input_exemplar[i], 'why', code_valid_len[i]))\n...    print(\"how-it-is-done:\", prediction(input_code[i], input_exemplar[i], 'done', code_valid_len[i]))\n...    print(\"usage:\", prediction(input_code[i], input_exemplar[i], 'usage', code_valid_len[i]))\n...    print(\"property:\", prediction(input_code[i], input_exemplar[i], 'property', code_valid_len[i]))\n...    print(\"=============================================================================\")\n\ncode:\n public int hashCode(){\n  return value.hashCode();\n}\nwhat: generates a hash code .\nwhy: generates code for this object .\nhow-it-is-done: a method that generates a hashcode based on the contents of the string representations .\nusage: this method is used when this class is used as the code .\nproperty: return a hashcode for this text attribute .\n=============================================================================\n\ncode:\n protected void writeQualifiedName(String nsAlias,String name) throws IOException {\n  if (nsAlias != null && nsAlias.length() > 0) {\n    writer.write(nsAlias);\n    writer.write(':');\n  }\n  writer.write(name);\n}\nwhat: writes a qualified name to a file .\nwhy: writes the beginning of the generated name to the given alias .\nhow-it-is-done: copy a qualified name , using the given class .\nusage: below method will be used to write the idex file\nproperty: returns a managed name path holding the value of the specified string .\n=============================================================================\n\ncode:\n <T>List<T> onFind(Class<T> modelClass,String[] columns,String[] conditions,String orderBy,String limit,boolean isEager){\n  BaseUtility.checkConditionsCorrect(conditions);\n  List<T> dataList=query(modelClass,columns,getWhereClause(conditions),getWhereArgs(conditions),null,null,orderBy,limit,getForeignKeyAssociations(modelClass.getName(),isEager));\n  return dataList;\n}\nwhat: handles the native query of the given table .\nwhy: the open interface for other classes in crud package to query the first record in a table .\nhow-it-is-done: finds genericvalues by the conditions specified in the backwards conditions object , the where clause is the product of each of the type .\nusage: method modified just override here before executing your test cases .\nproperty: returns the order of the order specified\n=============================================================================\n```\n\nFor more detailed usage and examples, please refer to the [DOME_Application.ipynb](https://github.com/ICSE-DOME/DOME/blob/master/DOME_Application.ipynb).\n",
                "type": "Text_excerpt",
                "original_header": "Using DOME to generate various comments that are coherent with the given intents",
                "parent_header": [
                    "ICSE22_DOME",
                    "3 Application"
                ]
            },
            "confidence": 1,
            "technique": "header_analysis",
            "source": "https://raw.githubusercontent.com/icse-dome/dome/master/README.md"
        }
    ],
    "full_title": [
        {
            "result": {
                "type": "String",
                "value": "ICSE22_DOME"
            },
            "confidence": 1,
            "technique": "regular_expression",
            "source": "https://raw.githubusercontent.com/icse-dome/dome/master/README.md"
        }
    ],
    "related_papers": [
        {
            "result": {
                "type": "Url",
                "value": "https://arxiv.org/pdf/2207.05579"
            },
            "confidence": 1,
            "technique": "regular_expression",
            "source": "https://raw.githubusercontent.com/icse-dome/dome/master/README.md"
        }
    ]
}